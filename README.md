
# ТСПП. Экзамен 2014. Ответы

# Билет 1. Типовые программные модели, используемые при разработке прикладных программ.

Всі існуючі прикладні програмні забезпечення ( ППЗ ) відносяться до одного з наступних видів:

1. Незалежні програми ;
2. Бібліотеки підпрограм ;
3. Мовні процесори ;
4. Багатофункціональні програми ;
5. Пакети прикладних програм ( ППП ) .

### Незалежні програми мають найпростішу структуру :

	P = <G , P> (головна програма і деяка підмножина процедур та функцій)
	
Головна характеристика незалежних програм : для введення вихідних даних і виводу результату використовуються оператори мови програмування.

### Бібліотеки підпрограм ( допоміжний елемент ПЗ ):

	P = < P >

### Мовні процесори містять деяку мову і  компілятор з цієї мови (мова - символьна) :

	C = < L , C >

### Багатофункціональні програми складаються з мовного процесора і однієї або декількох незалежних програм : 

	P = < C , P >

### ППП складаються з мовного процесора + незалежні програми + деяка база даних + керуючий пакет :

	P = < C , P , M , F >
	
# Билет 2. Программная инженерия в процессе создания программного обеспечения.  Технологии проектирования ПО.

Розробка програмного коду передує аналізом і проектуванням (перше означає створення функціональної моделі майбутньої системи без урахування реалізації, для усвідомлення програмістами вимог і очікувань замовника; друге означає попередній макет, ескіз, план системи на папері). Трудови трати на аналіз і проектування, а також форма представлення їх результатів сильно варіюються від видів проектів і переваг розробників і замовників.

Розробку системи також необхідно виконувати з урахуванням зручностей її подальшого супроводу, повторного використання і інтеграції з іншими системами. Це означає, що система розбивається на компоненти, зручні в розробці, придатні для повторного використання і інтеграції. А також необхідні характеристики, що мають, по швидкодії. 
Для цих компонент ретельно опрацьовуються інтерфейси. Сама ж система документується на багатьох рівнях, створюються правила оформлення програмного коду – тобто оставляются численні семантичні сліди, що допомагають створити і зберегти, підтримувати єдину, струнку архітектуру, одноманітний стиль, порядок.

Всі ці і інші додаткові види діяльності, що виконуються в процесі промислового програмування і необхідні для успішного виконання замовлень і називатимемо програмною інженерією (software engineering). Виходить, що так ми позначаємо, по-перше, деяку практичну діяльність, а по-друге, спеціальну область знання. Або іншими словами, наукову дисципліну. Адже для полегшення виконання кожного окремого проекту, для можливості використовувати різноманітний позитивний досвід, досягнутий іншими командами і розробниками, цей самий досвід піддається осмисленню, узагальненню і належному оформленню. Так з'являються різні методи і практики (best practices) – тестування, проектування, роботи над вимогами і ін., архітектурних шаблонів і ін. А також стандарти і методології, що стосуються всього процесу в цілому (наприклад, MSF, RUP, CMMI, Scrum). Ось ці-то узагальнення і входять в програмну інженерію як в область знання.

Програмна інженерія використовує досягнення інформатики, тісно пов'язана з системотехнікою, часто передує бизнес-реинжинирингом. Трохи докладніше про цей контекст програмної інженерії.

**Информатика** (computer science) – это свод теоретических наук, основанных на математике и посвященных формальным основам вычислимости. Сюда относят математическую логику, теорию грамматик, методы построения компиляторов, математические формальные методы, используемые в верификации и модельном тестировании и т.д. Трудно строго отделить программную инженерию от информатики, но в целом направленность этих дисциплин различна. Программная инженерия нацелена на решение проблем производства, информатика – на разработку формальных, математизированных подходов к программированию.

**Системотехніка** (system engineering) об'єднує різні інженерні дисципліни по розробці всіляких штучних систем – енергоустановок, телекомунікаційних систем, вбудованих систем реального часу і так далі Дуже часто ПО виявляється частиною таких систем, виконуючи завдання управління відповідного устаткування. Такі системи називаються програмно-апаратними, і беручи участь в їх створенні, програмісти вимушені глибоко розбиратися в особливостях відповідної апаратури.

**Бізнес-рєїнжінірінг** (business reengineering) – в широкому сенсі позначає модернізацію бізнесу в певній компанії, впровадження нових практик, підтримуваних відповідними, новими інформаційними системами. При цьому акцент може бути як на внутрішньому перевлаштуванні компанії так і на розробці нового клієнтського сервісу (як правило, ці питання взаємозв'язані). Бізнес-рєїнжінірінг часто передує розробці і впровадженню інформаційних систем на підприємстві, оскільки потрібний спочатку навести певний лад в діловодстві, а лише потім закріпити його інформаційною системою.

Зв'язок програмної інженерії (як області практичної діяльності) з інформатикою, системотехнікою і бизнес-реинжинирингом показана на рис. 2.1.

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-21%20at%2022.34.20.png?_subject_uid=76410387&w=AADrQ9SHDlljQpIkW-zH0CMsl8WI7RL6iJU0Uism6JyCcw)

# Билет 3. Техническое задание (технические требования ) на программную систему.

## Понятие ТЗ
**Техническое задание** — исходный документ на проектирование технического объекта (изделия). ТЗ устанавливает основное назначение разрабатываемого объекта, его технические характеристики, показатели качества и технико-экономические требования, предписание по выполнению необходимых стадий создания документации (конструкторской, технологической, программной и т. д.) и её состав, а также специальные требования.

Техническое задание также используется при создании творческого объекта (видеоролик, статья, графическое изображение, сайт).

Техническое задание является юридическим документом — как приложение включается в договор между заказчиком и исполнителем на проведение проектных работ и является его основой: определяет порядок и условия работ, в том числе цель, задачи, принципы, ожидаемые результаты и сроки выполнения. То есть должны быть объективные критерии, по которым можно определить, сделан ли тот или иной пункт работ или нет.

Все изменения, дополнения и уточнения формулировок ТЗ обязательно согласуются с заказчиком и им утверждаются. Это необходимо и потому, что в случае обнаружения в процессе решения проектной задачи неточностей или ошибочности исходных данных возникает необходимость определения степени вины каждой из сторон-участниц разработки, распределения понесенных в связи с этим убытков.


# Билет 4. Классический жизненный цикл разработки программного обеспечения
     
Старейшей парадигмой процесса разработки ПО является классический жизненный цикл (автор Уинстон Ройс, 1970).

Очень часто классический жизненный цикл называют каскадной или
водопадной моделью, подчёркивая, что разработка рассматривается как
последовательность этапов, причём переход на следующий, иерархически
нижний этап происходит только после полного завершения работ на текущем этапе.

Охарактеризуем содержание основных этапов.

Подразумевается, что разработка начинается на системном уровне и
проходит через анализ, проектирование, кодирование, тестирование и сопровождение. При этом моделируются действия стандартного инженерного цикла.

Системный анализ задаёт роль каждого элемента в компьютерной
системе, взаимодействие элементов друг с другом. Поскольку ПО является лишь частью большой системы, то анализ начинается с определения требований ко всем системным элементам и назначения подмножества этих требований программному «элементу». 

Необходимость системного подхода явно проявляется, когда формируется интерфейс ПО с другими элементами (аппаратурой, людьми, базами данных). На этом же этапе начинается решение задачи планирования проекта ПО. В ходе планирования проекта определяются объём проектных работ и их риск, необходимые трудозатраты, формируются рабочие задачи и план-график работ.

Анализ требований относится к программному элементу – программному обеспечению. Уточняются и детализируются его функции,
характеристики и интерфейс.

Все определения документируются в спецификации анализа. Здесь
же завершается решение задачи планирования проекта.

Проектирование состоит в создании представлений:

- архитектуры ПО
- модульной структуры ПО
- алгоритмической структуры ПО
- структуры данных
- входного и выходного интерфейса (входных и выходных форм
данных).

Исходные данные для проектирования содержатся в спецификации анализа, т.е. в ходе проектирования выполняется трансляция требований к ПО во множество проектных представлений. При решении задач проектирования основное внимание уделяется качеству будущего программного
продукта.

Кодирование состоит в переводе результатов проектирования в текст
на языке программирования.

**Тестирование** – выполнение программы для выявления дефектов в
функциях, логике и форме реализации программного продукта.

**Сопровождение** – это внесение изменений в эксплуатируемое ПО.

**Цели изменений:**

- исправление ошибок
- адаптация к изменениям внешней для ПО среды
-  усовершенствование ПО по требованиям заказчика.
     
Сопровождение ПО состоит в повторном применении каждого из
предшествующих шагов (этапов) жизненного цикла к существующей программе, но не в разработке новой программы.
     
Как и любая инженерная схема, классический жизненный цикл имеет
достоинства и недостатки.
     
Достоинства классического жизненного цикла: даёт план и временной график по всем этапам проекта, упорядочивает ход конструирования.

Недостатки классического жизненного цикла:

1. реальные проекты часто требуют отклонения от стандартной последовательности шагов
2. цикл основан на точной формулировке исходных требований к ПО (реально в начале проекта требования заказчика определены лишь
частично)
- результаты проекта доступны заказчику только в конце работы.

# Билет 5. Быстрая разработка приложений

**Модель быстрой разработки приложений RAD** (Rapid Application
Development) – второй пример применения инкрементной стратегии кон-
струирования (рис. 4.5).

**RAD-модель** обеспечивает экстремально короткий цикл разработки.
RAD – высокоскоростная адаптация линейной последовательной модели, в которой быстрая разработка достигается за счёт использования компонентно-ориентированного конструирования. Если требования полностью определены, а проектная область ограничена, RAD-процесс позволяет группе создать полностью функциональную систему за очень короткое время (60 – 90 дней). RAD-подход ориентирован на разработку информа-
ционных систем и выделяет следующие этапы:

![](http://skachate.ru/pars_docs/refs/18/17663/17663_html_14570589.png)

- бизнес-моделирование. Моделируется информационный поток
между бизнес-функциями. Ищется ответ на следующие вопросы: какая ин-
формация руководит бизнес-процессом? Какая информация генерируется?
Кто генерирует её? Где информация применяется? Кто обрабатывает её?

- моделирование данных. Информационный поток, определённый
на этапе бизнес-моделирования, отображается в набор объектов данных,
которые требуются для поддержки бизнеса. Идентифицируются характе-
ристики (свойства, атрибуты) каждого объекта, определяются отношения
между объектами;

- моделирование обработки. Определяются преобразования объ-
ектов данных, обеспечивающие реализацию бизнес-функций. Создаются
описания обработки для добавления, модификации, удаления или нахож-
дения (исправления) объектов данных;

- генерация приложения. Предполагается использование методов,
ориентированных на языки программирования 4-го поколения. Вместо
создания ПО с помощью языков программирования 3-го поколения, RAD-
процесс работает с повторно используемыми программными компонента-
ми или создаёт повторно используемые компоненты. Для обеспечения
конструирования используются утилиты автоматизации;
         
- тестирование и объединение. Поскольку применяются повторно
используемые компоненты, многие программные элементы уже протести-
рованы. Это уменьшает время тестирования (хотя все новые элементы
должны быть протестированы).

Применение RAD возможно в том случае, когда каждая главная функ-
ция может быть завершена за 3 месяца. Каждая главная функция адресуется
отдельной группе разработчиков, а затем интегрируется в целую систему.

Применение RAD имеет и свои недостатки, и ограничения.

1. Для больших проектов в RAD требуются существенные людские
ресурсы (необходимо создать достаточное количество групп).
2. RAD применима только для таких приложений, которые могут
декомпозироваться на отдельные модули и в которых производительность
не является критической величиной.
3. RAD не применима в условиях высоких технических рисков
(т.е. при использовании новой технологии).

# Билет 6. Спиральный жизненный цикл разработки программного обеспечения

**Спиральная модель** – классический пример применения эволюционной стратегии конструирования.

Спиральная модель (автор Барри Боэм, 1988) базируется на лучших свойствах классического жизненного цикла и макетирования, к которым
добавляется новый элемент – анализ риска, отсутствующий в этих парадигмах.

Как показано на рисунке 4.6, модель определяет четыре действия,
представляемые четырьмя квадрантами спирали.

1. Планирование – определение целей, вариантов и ограничений.
2. Анализ риска – анализ вариантов и распознавание/выбор риска.
3. Конструирование – разработка продукта следующего уровня.
4. Оценивание – оценка заказчиком текущих результатов конструирования.

Интегрирующий аспект спиральной модели очевиден при учёте радиального измерения спирали. С каждой итерацией по спирали (продвижением от центра к периферии) строятся всё более полные версии ПО.

В первом витке спирали определяются начальные цели, варианты и ограничения, распознаётся и анализируется риск. Если анализ риска показывает неопределённость требований, на помощь разработчику и заказчику приходит макетирование (используемое в квадранте конструирования).

1. начальный сбор требований и планирование проекта; 
2. та же работа, но на основе рекомендаций заказчика; 
3. анализ риска на основе начальных требований;
4. анализ риска на основе реакции заказчика; 
5. переход к комплексной системе; 
6. начальный макет системы; 
7. следующий уровень макета;
8. сконструированная система; 
9. оценивание заказчиком

Для дальнейшего определения проблемных и уточнённых требований может быть использовано моделирование. Заказчик оценивает инженерную (конструкторскую) работу и вносит предложения по модификации (квадрант оценки заказчиком). Следующая фаза планирования и анализа риска базируется на предложениях заказчика. В каждом цикле по
спирали результаты анализа риска формируются в виде «продолжать, не продолжать». Если риск слишком велик, проект может быть остановлен.

В большинстве случаев движение по спирали продолжается, с каж-
дым шагом продвигая разработчиков к более общей модели системы.

В каждом цикле по спирали требуется конструирование (нижний правый квадрант), которое может быть реализовано классическим жизненным циклом или макетированием. Заметим, что количество действий по разработке (происходящих в правом нижнем квадранте) возрастает по мере продвижения от центра спирали.

## Достоинства спиральной модели:

1. наиболее реально (в виде эволюции) отображает разработку программного обеспечения;
2. позволяет явно учитывать риск на каждом витке эволюции разработки;
3. включает шаг системного подхода в итерационную структуру разработки;
4. использует моделирование для уменьшения риска и совершенствования программного изделия.

## Недостатки спиральной модели:

1. новизна (отсутствует достаточная статистика эффективности модели)
2. повышенные требования к заказчику;
3. трудности контроля и управления временем разработки
4. использует моделирование для уменьшения риска и совершенствования программного изделия.

# Билет 7. Экстремальное программирование

**Экстремальное программирование (XP)** – это упрощенная методология организации разработки программ для небольших и средних по размеру команд разработчиков, занимающихся созданием программного продукта в условиях неясных или быстро меняющихся требований.

## Цели XP

Основными целями XP являются повышение доверия заказчика к программному продукту путем предоставления реальных доказательств успешности развития процесса разработки и резкое сокращение сроков разработки продукта. При этом XP сосредоточено на минимизации ошибок на ранних стадиях разработки. 

## Принципы XP

Основными принципами являются:
- Итеративность. Разработка ведется короткими итерациями при наличии активной взаимосвязи с заказчиком. Итерации как таковые предлагается делать короткими, рекомендуемая длительность – 2-3 недели и не более 1 месяца. За одну итерацию группа программистов обязана реализовать несколько свойств системы, каждое из которых описывается в пользовательской истории. Пользовательские истории (ПИ) в данном случае являются начальной информацией, на основании которой создается модуль. Они отличаются от вариантов использования (ВИ). Описание ПИ короткое – 1-2 абзаца, тогда как ВИ обычно описываются достаточно подробно, с основным и альтернативными потоками, и дополняются моделью. ПИ пишутся самими пользователями, которые в XP являются частью команды, в отличие от ВИ, которые описывает системный аналитик. Отсутствие формализации описания входных данных проекта в XP стремятся компенсировать за счет активного включения в процесс разработки заказчика как полноправного члена команды.
- Простота решений. Принимается первое простейшее рабочее решение. Экстремальность метода связана с высокой степенью риска решения, обусловленного поверхностностью анализа и жестким временным графиком. Реализуется минимальный набор главных функций системы на первой и каждой последующей итерации; функциональность расширяется на каждой итерации.
- Интенсивная разработка малыми группами (не больше 10 человек) и парное программирование (когда два программиста вместе создают код на одном общем рабочем месте), активное общение в группе и между группами. Все это нацелено на как можно более раннее обнаружение проблем (как ошибок, так и срыва сроков). Парное программирование направлено на решение задачи стабилизации проекта. При применении XP методологии высок риск потери кода по причине ухода программиста, не выдержавшего интенсивного графика работы. В этом случае второй программист из пары играет роль «наследника» кода. Немаловажно и то, как именно распределены группы в рабочем пространстве – в XP используется открытое рабочее пространство, которое предполагает быстрый и свободный доступ всех ко всем.
- Обратная связь с заказчиком, представитель которого фактически вовлечен в процесс разработки.
- Достаточная степень смелости и желание идти на риск.

## Приемы XP (практики)

Обычно XP характеризуют набором из 12 правил (практик), которые необходимо выполнять для достижения хорошего результата. Ни одна из практик не является принципиально новой, но в XP они собраны вместе.

1.	Планирование процесса. Вся команда разработчиков собирается вместе, принимается коллективное решение о том, какие свойства системы будут реализованы в ближайшей итерации. Трудоемкость реализации каждого свойства определяется самими программистами.
2.	Тесное взаимодействие с заказчиком. Представитель заказчика должен быть членом XP-команды. Он пишет ПИ, выбирает истории, которые будут реализованы в конкретной итерации, и отвечает на вопросы, касающиеся бизнеса. Представитель заказчика должен быть экспертом в автоматизируемой предметной области. Необходимо наличие постоянное обратной связи с представителем заказчика.
3.	Общесистемные правила именования. Хорошие системные правила именования предполагают простоту именования классов и переменных. Команда разработчиков должна иметь единые правила именования.
4.	Простая архитектура. Любое свойство системы должно быть реализовано как можно проще. Программисты в XP-команде работают под девизом: «Ничего лишнего!». Принимается первое простейшее работающее решение, реализуется необходимый уровень функциональности на данный момент. Тем самым экономится время программиста.
5.	Рефакторинг. Это оптимизация существующего кода с целью его упрощения, Такая работа должна вестись постоянно. Сохраняя код прозрачным и определяя его элементы всего один раз, программисты сокращают число ошибок, которые впоследствии придется устранять. При реализации каждого нового свойства системы программист должен подумать над тем, можно ли упростить существующий код и как это поможет реализовать новое свойство. Кроме того, нельзя совмещать рефакторинг с дизайном: если создается новый код, рефакторинг следует отложить.
6.	Парное программирование. Все программисты должны работать в парах: один пишет код, другой смотрит. Таким образом, необходимо размещать группу программистов в одном месте. XP наиболее успешно работает в нераспределенных коллективах программистов и пользователей.
7.	40-часовая рабочая неделя. Программист не должен работать более 8 часов в день. Необходимость сверхурочной работы – это четкий индикатор проблемы на данном конкретном направлении разработки. Поиск причин сверхурочной работы и их скорейшее устранение – одно из основных правил.
8.	Коллективное владение кодом. Каждый программист в коллективе должен иметь доступ к коду любой части системы и право вносить изменения в любой код. Обязательное правило: если программист внес изменения и система после этого работает некорректно, то именно этот программист должен исправить ошибки.
9.	Единые стандарты кодирования. Стандарты кодирования нужны для обеспечения других практик: коллективного владения кодом, парного программирования и рефакторинга. Без единого стандарта выполнять эти практики как минимум сложнее, а в реальности вообще невозможно: группа будет работать в режиме постоянной нехватки времени. Команда работает над проектом продолжительное время. Люди приходят и уходят. Никто не кодирует в одиночку и код принадлежит всем. Всегда будут моменты, когда необходимо будет понять и скорректировать чужой код. Разработчики будут удалять дублирующий код, анализировать и улучшать чужие классы и т. п. Со временем нельзя будет сказать, кто автор конкретного класса. Следовательно, все должны подчиняться общим стандартам кодирования – форматирование кода, именование классов, переменных, констант, стиль комментариев. Вышесказанное означает, что все члены команды должны договориться об общих стандартах кодирования. Неважно каких, но все обязаны им подчиняются.
10.	Небольшие релизы. Минимальная итерация – один день, максимальная – месяц; чем чаще осуществляются релизы, тем больше недостатков системы будет выявлено. Первые релизы помогают выявить недостатки на самых ранних стадиях, далее функциональность системы расширяется на основании ПИ. Поскольку пользователь включается в процесс разработки начиная с первого релиза, то он оценивает систему и выдает пользовательскую историю и замечания. На основании этого определяется следующая итерация, то есть, каким будет новый релиз. В XP все направлено на обеспечение непрерывной обратной связи с пользователями.
11.	Непрерывная интеграция. Интеграция новых частей системы должна происходить как можно чаще, как минимум раз в несколько часов. Основное правило интеграции следующее: интеграцию можно производить, если все тесты проходят успешно. Если тесты не проходят, то программист должен либо внести исправления и тогда интегрировать составные части системы, либо вообще не интегрировать их. Правило это – жесткое и однозначное. Если в созданной части системы имеется хотя бы одна ошибка, то интеграцию производить нельзя. Частая интеграция позволяет быстрее получить готовую систему, вместо того чтобы тратить на сборку неделю.
12.	Тестирование. В отличие от большинства остальных методологий тестирование в XP – одно из важнейших составляющих. Экстремальный подход предполагает, что тесты пишутся до написания кода. Каждый модуль обязан иметь unit test – тест данного модуля. Таким образом, в XP осуществляется регрессионное тестирование, «неухудшение качества» при добавлении функциональности. Большинство ошибок исправляются на стадии кодирования. Тесты пишут сами программисты, любой из них имеет право написать тест для любого модуля. Еще один важный принцип: тест определяет код, а не наоборот (test-driven development), то есть кусок кода кладется в хранилище тогда и только тогда, когда все тесты прошли успешно, в противном случае данное изменение кода отвергается.

Процесс XP является неформальным, но требует высокого уровня самодисциплины. Если это правило не выполняется, то XP мгновенно превращается в хаотичный и неконтролируемый процесс. XP не требует от программистов написания множества отчетов и построения массы моделей. 

В XP каждый программист считается квалифицированным работником, который профессионально и с большой ответственностью относится к своим обязанностям. Если в команде этого нет, то внедрять XP абсолютно бессмысленно – лучше для начала заняться перестройкой команды. Риск разработки снижается только в команде, которой XP подходит идеально, во всех остальных случаях XP – это процесс разработки с наиболее высокой степенью риска, поскольку другие методы снижения коммерческих рисков, кроме человеческого фактора, в XP просто отсутствуют.

# Билет 8. Каскадна модель

У спочатку існуючих однорідних ІС кожне застосування було єдиним цілим. Для розробки такого типу додатків застосовувався каскадний спосіб. Його основною характеристикою є розбиття всієї розробки на етапи, причому перехід з одного етапу на наступний відбувається тільки після того, як буде повністю завершена робота на поточному (рис. 4.1). Кожен етап завершується випуском повного комплекту документації, достатньої для того, щоб розробка могла бути продовжена іншою командою розробників. 

Позитивні сторони застосування каскадного підходу полягають в наступному: 
- на кожному етапі формується закінчений набір проектної документації, що відповідає критеріям повноти і узгодженості;
- виконувані в логічній послідовності етапи робіт дозволяють планувати терміни завершення всіх робіт і відповідні витрати.

![](http://wiki.mvtom.ru/images/4/4c/Рис1.gif)

Каскадний підхід добре зарекомендував себе при побудові ІС, для яких на самому початку розробки можна достатньо точно і повно сформулювати всі вимоги, з тим щоб надати розробникам свободу реалізувати їх якнайкраще з технічної точки зору. У цю категорію потрапляють складні розрахункові системи, системи реального часу і інші подібні завдання. Проте, в процесі використання цього підходу виявилися ряд його недоліків, викликаних перш за все тим, що реальний процес створення ПО ніколи повністю не укладався в таку жорстку схему. В процесі створення ПО постійно виникала потреба в поверненні до попередніх етапів і уточненні або перегляді раніше ухвалених рішень. В результаті реальний процес створення ПО приймав наступний вигляд (рис.. 4.2): 

![](http://www.bestreferat.ru/images/paper/34/83/7598334.png)

Основным недостатком каскадного подхода является существенное запаздывание с получением результатов. Согласование результатов с пользователями производится только в точках, планируемых после завершения каждого этапа работ, требования к ИС "заморожены" в виде технического задания на все время ее создания. В случае неточного изложения требований или их изменения в течение длительного периода создания ПО, пользователи получают систему, не удовлетворяющую их потребностям.. 


# Билет 9. Качество ПО. Модель зрелости организаций разработчиков ПО.

Capability Maturity Model — модель зрелости возможностей создания ПО: эволюционная модель развития способности компании разрабатывать программное обеспечение.

Уровень зрелости представляет собой точно определенное эволюционное плато на пути к достижению полной зрелости производственного процесса. Каждый уровень зрелости формирует отдельный слой фундамента для постоянного совершенствования производственного процесса, включает в себя набор целей процесса, которые, по мере их достижения, приводят к стабилизации значимых компонентов производственного процесса. Достижение каждого уровня структуры зрелости характеризуется внедрением различных составляющих производственного процесса, повышающих его продуктивность.

Последующие характеристики пяти уровней зрелости раскрывают основные изменения процессов, проводимые на каждом из них.

**Начальный** производственный процесс (ПП) характеризуется как создаваемый каждый раз под конкретный проект, а иногда даже как хаотический. Определены лишь некоторые процессы и успех проекта зависит от усилий индивидуумов.

Находясь на начальном уровне, организация обычно не может обеспечить устойчивый процесс разработки и сопровождения ПО. Когда в организации отсутствует культура управления, преимущества применения хороших решений в процессе проектирования исчезают из-за неэффективного планирования и плохой работы систем согласования.

**Повторяемый**: установлены основные процессы управления проектом, позволяющие отслеживать затраты, следить за графиком работ и функциональностью создаваемого программного решения. Установлена дисциплина процесса, необходимая для повторения достигнутых ранее успехов в проектах разработки подобных приложений.

**Определенный** производственный процесс документирован и стандартизован как для управленческих работ, так и для проектирования. Этот процесс интегрирован в стандартный производственный процесс организации. Во всех проектах используется утвержденная адаптированная версия стандартного производственного процесса организации.

**Управляемый**: cобираются подробные количественные показатели производственного процесса и качества создаваемого продукта. Как производственный процесс, так и продукты оцениваются и контролируются с количественной точки зрения.

**Оптимизирующий** постоянное совершенствование процесса достигается благодаря количественной обратной связи с процессом и реализации передовых идей и технологий.

# Билет 10. Измерения, меры и метрики ПО.

Як перевіряти і оцінювати? 

Перш за все, визначимо, що треба перевіряти і оцінювати:

- Загальний хід виконання проекту
- Виконання окремих видів робіт
- Роботу окремих виконавців

Об'єктивно оцінити і проконтролювати можна тільки те, що можна зміряти. Для об'єктивної оцінки необхідно вводити метрики проекту – кількісні показники оцінки різних характеристик проекту і процесу його виконання. Метрики можуть вводитися як для всього проекту в цілому, так і для окремих видів робіт. Загальними метриками проекту є:

- Кількість фаз / дій / робіт
- Тривалість кожної роботи
- Вартість ресурсів, вартість роботи, загальна вартість
- Ступінь завантаження ресурсів і виконавців на окремих етапах
- Кількість завершених робіт
- Кількість змін в проекті
- Затримки випуску
- Вартість зміни вимог

# Билет 11. Размерно ориентированные метрики ПС.

Розмірно-орієнтовані метрики прямо вимірюють програмний продукт і процес його розробки. Грунтуються розмірно-орієнтовані метрики на LOC-оценках (Lines Of Code). LOC-оценка — це кількість рядків в програмному продукті.

Початкові дані для розрахунку цих метрик зводяться в таблицю (табл. 15.1). 
Таблиця 15.1. Початкові дані для розрахунку LOC-метрик

| Проект | Витрати, чіл.мес | Вартість, тис. $ | KLOC, тис. LOC | Прогр. докти, сторінок | Помилки | Люди |
|-|-|-|-|-|-|-| 
|ааа01 | 24  | 168 | 12,1 |365 |29 |3 |
|bbb02 | 62 | 440  | 27,2  |1224 |86  |5 |
|ссс03 |43  |314  |20,2  |1050  |64  |6|
 
Таблиця містить дані про проекти за останні декілька років. Наприклад, запис про проект aaa01 показує: 12 100 рядків програми було розроблено за 24 людино-місяці і коштували $168 000. Крім того, за проектом aaa01 було розроблено 365 сторінок документації, а протягом першого року експлуатації було зареєстровано 29 помилок. Розробляли проект aaa01 три люди.

На основі таблиці обчислюються розмірно-орієнтовані метрики продуктивності і якості (для кожного проекту):

**ПРОИЗВОДИТЕЛЬНОСТЬ** = ДЛИНА (тыс. LOC) / ЗАТРАТЫ (чел-мес)

**КАЧЕСТВО** = ОШИБКИ (ед) / ДЛИНА (тыс. LOC)

**УДЕЛЬНАЯ СТОИМОСТЬ** = СТОИМОСТЬ (тыс $) / ДЛИНА (LOC)

**ДОКУМЕНТИРОВАННОСТЬ** = СТРАНИЦ ДОКУМЕНТА / ДЛИНА (тыс. LOC)


Достоїнства розмірно-орієнтованих метрик:

1. широко поширені;
2. прості і легко обчислюються. 

Недоліки розмірно-орієнтованих метрик:

1. залежні від мови програмування;
2. вимагають початкових даних, які важко отримати на початковій стадії проекту;
3. не пристосовані до непроцедурних мов програмування
 
# Билет 12. Функционально ориентированные метрики.

**Функціонально-орієнтовані метрики** побічно вимірюють програмний продукт і процес його розробки. На відміну від підрахунку LOC-оцінки при цьому розглядається не розмір, а функціональність або корисність продукту.

Використовується 5 інформаційних характеристик.

1.	**Кількість зовнішніх введень**. Підраховуються всі введення користувача, по яких поступають різні прикладні дані. Введення повинні бути відокремлені від запитів, які підраховуються окремо.
2.	**Кількість зовнішніх виводів**. Підраховуються всі виводи, по яких до користувача поступають результати, обчислені програмним застосуванням. У цьому контексті виводи означають звіти, екрани, роздруки, повідомлення про помилки. Індивідуальні одиниці даних усередині звіту окремо не підраховуються.
3.	**Кількість зовнішніх запитів**. Під запитом розуміється діалогове введення, яке приводить до негайної програмної відповіді у формі діалогового виводу. При цьому діалогове введення в додатку не зберігається, а діалоговий вивід не вимагає виконання обчислень. Підраховуються всі запити — кожен враховується окремо.
4.	**Кількість внутрішніх логічних файлів**. Підраховуються всі логічні файли (тобто логічні групи даних, які можуть бути частиною бази даних або окремим файлом).
5.	**Кількість зовнішніх інтерфейсних файлів**. Підраховуються всі логічні файли з інших застосувань, на які посилається дане застосування.

Введення, виводи і запити відносят до категорії транзакция. 

**Транзакция** — це елементарний процес, який бачить користувач і який переміщує дані між зовнішнім середовищем і програмним застосуванням. У своїй роботі транзакції використовують внутрішні і зовнішні файли. 

Кожній з виявлених характеристик ставиться у відповідність складність. Для цього характеристиці призначається низький, середній або високий ранг, а потім формується числова оцінка рангу.

Для транзакцій ранжирування засноване на кількості посилань на файли і кількості типів елементів даних. Для файлів ранжирування засноване на кількості типів елементів-записів і типів елементів даних, що входять у файл.

**Тип елементу-запису** — підгрупа елементів даних, розпізнаваєма користувачем в межах файлу.
**Тип елементу даних** — унікальне не рекурсивне (неповторюване) поле, розпізнаване користувачем.

**Достоїнства функціонально-орієнтованих метрик:**

1. Не залежать від мови програмування.
2. Легко обчислюються на будь-якій стадії проекту.

**Недолік функціонально-орієнтованих метрик**

1. результати засновані на суб'єктивних даних
2. використовуються не прямі, а непрямі вимірювання

FP-оцінки легко перерахувати в LOC-оцінки. 

# Билет 13. Вычисление функциональных указателей и указателей свойств.
Після збору всієї необхідної інформації для функціональних метрик, приступають до розрахунку метрики — кількості функціональних покажчиків FP (Function Points). Автором цієї метрики є А. Албрехт (1979).

Початкові дані для розрахунку зводяться в табл. 1. 

Таблиця 1. Початкові дані для розрахунку FP-метрик


| Ім'я характеристики | Ранг, складність, кількість | ||||
|-|-|-|-|-|
|-| Низький | Середній  | Високий | Разом |
| Зовнішні введення | 0x3 = __ | 0x4 = __ |0x6 = __  |= 0 |
| Зовнішні виводи | 0x4 = __ | 0x5 = __ | 0x7 = __ | = 0 |
| Зовнішні запити | 0х3 = __ | 0x4 = __ | 0x6 = __ | = 0 |
| Внутрішні логічні файли | 0x7 = __ | 0x 10= __  | 0x15 = __ | = 0 |
| Зовнішні інтерфейсні файли  | 0x5 = __  | 0x7 = __  | 0x10 = __  | = 0 |
|Загальна кількість | = 0 |

Кількість функціональних покажчиків обчислюється за формулою

	FP = Загальна кількість х (0,65+ 0,01 x Sum _i=1^14 Fi)), (1)
	
де Fi — коефіцієнти регулювання складності.

Кожен коефіцієнт може набувати наступних значень: 0 — немає впливу, 1 — випадкове, 2 — невелике, 3 — середнє, 4 — важливе, 5 — основне.

Після обчислення FP на його основі формуються метрики продуктивності, якості і т. д.:

ПРОИЗВОДИТЕЛЬНОСТЬ = ФУНКЦ УКАЗАТЕЛЬ / ЗАТРАТЫ

КАЧЕСТВО = ОШИБКИ / ФУНКЦ УКАЗАТЕЛЬ

УДЕЛЬНАЯ СТОИМОСТЬ = СТОИМОСТЬ / ФУНКЦ УКАЗАТЕЛЬ

ДОКУМЕНТИРОВАННОСТЬ = СТРАНИЦ ДОКУМЕНТА / ФУНКЦ УКАЗАТЕЛЬ

Область використання метода функциональних покажчиків — коммерційні інформаційні системи. Для продуктів с высокою алгоритмичною слкладністю використовуються метрики покажчиків властивостей (Features Points). Вони застосовуються до системноого та інженерного ПЗ, ПЗ реального часу і вбудованого ПЗ.

Для обчислення покажчика властивостей додається одна характеристика — кількість алгоритмів. Алгоритм тут визначається як обмежена підпрограма обчислень, яка включається в загальну комп'ютерну програму. Приклади алгоритмів: обробка переривань, інвертування матриці, розшифровка бітового рядка. Для формування покажчика властивостей складається табл 2.

Таблиця 2. Початкові дані для розрахунку покажчика властивостей

| № | Характеристика | Кількість  |Складність  |Разом |
|-|-|-|-|-|
| 1 | Введення | 0  |х4  |= 0 | 
| 2 | Виводи  | 0 | х5  | = 0 |
| 3 | Запити | 0| х4 |= 0 |
|4 | Логічні файли | 0 | х7 | = 0 |
| 5 | Інтерфейсні файли | 0 | х7 | = 0 |
| 6 | Кількість алгоритмів | 0 | х3| = 0 |
| Загальна кількість | = 0 |

Після заповнення таблиці за формулою 1 (вище формула для функ. показчиків) обчислюється значення покажчика властивостей. Для складних систем реального часу це значення на 25-30% більше значення, що обчислюється по таблиці для кількості функціональних покажчиків.

# Билет 17. Принципы декомпозиции подсистем на модули.

**Модульная программа** – это такая программа, в которой любую часть логической структуры можно изменить, не вызывая изменений в остальных частях программы.

В основу разработки модульных программ положен принцип модульной декомпозиции. Известны два типа моделей модульной декомпозиции:
- модель потока данных;
- модель объектов.

В основе модели потока данных лежит разбиение по функциям, используемое при разработке процедурно-ориентированных программных продуктов.

Модель объектов основана на слабо сцепленных сущностях, имеющих собственные наборы данных, состояния и наборы операций. Эта модель декомпозиции используется при разработке объектно-ориентированных ПП.

Выбор типа декомпозиции должен определяться сложностью разбиваемой программной системы.

**Модуль** – это фрагмент программного текста, являющийся строительным блоком для физической структуры системы. Как правило, модуль состоит из интерфейсной части и части-реализации.

**Модульность** – свойство системы, которая может подвергаться декомпозиции на ряд внутренне связанных и слабо зависящих друг от друга модулей. По определению Г. Майерса, модульность – свойство ПП, обеспечивающее интеллектуальную возможность создания сколько угодно сложной программы.

**Декомпозиция** означает разбиение некоторой сложной проблемы на ряд проще решаемых проблем, которые в свою очередь разделяются на подпроблемы до тех пор, пока каждая необходимая деталь не будет определена достаточно ясно.

**Строгая декомпозиция подчиняется нескольким правилам.**
1. на каждом уровне иерархии план или проект должен иметь законченный вид на данном уровне детализации.
2.  на любом уровне иерархии каждое разбиение полностью охватывает отдельную функцию, проблему или объект, соответствующий данному уровню детализации.

Некоторые формы иерархической декомпозиции представляют собой:
структурирование планов выпуска программного продукта, при котором большой проект разбивается на несколько последовательных выпусков версий программного продукта;

- нисходящие программирование;
- модульную декомпозицию;
- структурное проектирование программного продукта;
- построение объектной модели приложения;
- построение модели базы данных.

**Иерархическая структура** (модель), представляет собой совокупность элементов (объектов, модулей, версий программного продукта, и т.д.), расположенных в порядке их подчинения от общего к частному и образует перевернутое дерево (граф). Рассмотрение любой сложной программной системы требует применения техники декомпозиции – разбиения на составляющие элементы.

# Билет 18. Связность модуля

**Связность модуля** (Cohesion) — это мера зависимости его частей. 
*Связность* — внутренняя характеристика модуля. Чем выше связность модуля, тем лучше результат проектирования, то есть тем «черней» его ящик (капсула, защитная оболочка модуля), тем меньше «ручек управления» на нем находится и тем проще эти «ручки».

Для измерения связности используют понятие силы связности (СС). 

Существует 7 типов связности:

1. Связность по совпадению (СС=0). В модуле отсутствуют явно выраженные внутренние связи
2. Логическая связность (СС=1). Части модуля объединены по принципу функционального подобия.
3. Временная связность (СС=3). Части модуля не связаны, но необходимы в один и тот же период работы системы.
4. Процедурная связность (СС=5). Части модуля связаны порядком выполняемых действий, реализующих некий сценарий поведения.
5. Коммуникативная связность (СС=7). Части модуля связаны по данным (работают с одной и той же структурой данных).
6. Информационная (последовательная) связность (СС=9). Выходные данные одной части используются как входные в другой части модуля.
7. Функциональная связность (СС=10). Части модуля вместе реализуют одну функцию.

## Определение связности модуля

1. Если модуль — единичная проблемно-ориентированная функция, то уровень связности — функциональный; конец алгоритма. В противном случае перейти к пункту 2.
2. Если действия внутри модуля связаны, то перейти к пункту 3. Если действия внутри модуля никак не связаны, то перейти к пункту 6.
3. Если действия внутри модуля связаны данными, то перейти к пункту 4. Если действия внутри модуля связаны потоком управления, перейти к пункту 5.
4. Если порядок действий внутри модуля важен, то уровень связности — информационный. В противном случае уровень связности — коммуникативный. Конец алгоритма.
5. Если порядок действий внутри модуля важен, то уровень связности — процедурный. В противном случае уровень связности — временной. Конец алгоритма.
6. Если действия внутри модуля принадлежат к одной категории, то уровень связности — логический. Если действия внутри модуля не принадлежат к одной категории, то уровень связности — по совпадению. Конец алгоритма.

Возможны более сложные случаи, когда с модулем ассоциируются несколько уровней связности. В этих случаях следует применять одно из двух правил:

**Правило параллельной цепи:** Если все действия модуля имеют несколько уровней связности, модулю присваивают самый
сильный уровень связности.

**Правило последовательной цепи:** Если действия в модуле имеют разные уровни связности, то модулю присваивают самый слабый уровень связности.

# Билет 19. Сцепление модулей

**Сцепление** (Coupling) — мера взаимозависимости модулей по данным. ё

*Сцепление* — внешняя характеристика модуля, которую желательно уменьшать. Количественно сцепление измеряется степенью сцепления (СЦ). 

**Выделяют 6 типов сцепления:**

1. Сцепление по данным (СЦ=1). Модуль А вызывает модуль В. Все входные и выходные параметры вызываемого модуля – простые элементы данных.
2. Сцепление по образцу (СЦ=3). В качестве параметров используются структуры данных.
3. Сцепление по управлению (СЦ=4). Модуль А явно управляет функционированием модуля В, посылая ему управляющие данные.
4. Сцепление по внешним ссылкам (СЦ=5). Модули А и В ссылаются на один и тот же глобальный элемент данных.
5. Сцепление по общей области (СЦ=7). Модули разделяют одну и ту же глобальную структуру данных.
6. Сцепление по содержанию (СЦ=9). Один модуль прямо ссылается на содержание другого модуля (через его точку входа)..

# Билет 20. Принципы разработки пользовательского интерфейса.

Одним из важных показателей качества ПО является удобство его использования.

В понятие удобства использования входят такие характеристики ПО, как:

- понятность пользовательского интерфейса
- легкость обучения работе с ПО
- трудоемкость решения определенных задач с его помощью
- производительность работы пользователя с ПО
- частота появления жалоб на неубоства.

### Терпимость к ошибкам

Сравнимо медленная скорость восприятия по закону Фитса (Fitts) $
	
	—T = a + b*log(D/W) (иногда a + b*(D/W)½)$
	
### В кратковременной памяти не более 5-9 сущностей

Человек быстрее узнает что-то, чем вспоминает, как оно называется

### На изучение нового всегда требуется время

Внимание человека прежде всего акцентируется на движущихся объектах, затем — на выделяющихся цветом, и только потом на остальных формах выделения.

### Человеку свойственно ошибаться

Поэтому удобная система должна быть достаточно термима к ошибкам пользователей  и нив коем случае не рушится из-за ошибок ввода.

### Человек осознает информацию и производит действия достаточно медленно по меркам компьютеров

Около 0.1 секунды требуется для распознавание визуального объекта, около 0.25 секунды — на перевод взгляда и переключение внимания с одного объекта на другой, около 1.25 секунды — на принятие простейшего решения (выбор из двух альтернатив). Эти цифры должны учитываться при проектировании интерфейсов, рассчитанных на взаимодействие с человеком.

### Глаз быстрее руки — человек быстрее узнает что-то, чем производит действия.

На нажатие клавиши на клавиатуре или кнопки мыши уходит от 0.1 до 1.25 секунды, на наведение указателя мыши на объект — 1.5 секунды, на переключение внимания с мыши на клавиатуру уходит около 0.36 секунды.

Кроме того, скорость переноса указателя мыши зависит от дальности переноса D и размеров W объекта, на который нужно попасть по закону Фитса (Fitts) —

	T = a + b*log(D/W) (иногда a + b*(D/W)½)
	
В любом случае — чем больше объект, тем быстрее можно установить на него указатель. Кроме того, люди чаще всего промахиваются при первой попытке переместить указатель мыши.

### Правило 7±2.

Человек способен хранить в кратковременной памяти одновременно не более 5-9 отдельных сущностей. Существуют исключения из этого правила, но практически всегда разбираться в картинке, где изображено больше 10 объектов труднее, чем в той, где их меньше — ее тяжело охватить в целом.

### Человек гораздо быстрее узнает что-то, чем вспоминает, как оно называется.

Значительно проще выбрать что-то из списка, чем набрать его идентификатор или имя.
На изучение нового всегда требуется время. В начале работы с чем-то новым человек гораздо чаще совершает ошибки, даже если пытается решать уже известные ему задачи с помощью нового инструмента.

### Внимание человека прежде всего акцентируется на движущихся объектах, затем — на выделяющихся цветом, и только потом на остальных формах выделения.

Лучшим способом отвлечь человека от работы является появление цветных анимированных ненужных картинок.

## Основные правила построеняи удобного ПО могут быть сформулированы так.

### Правило доступности.

Система должна быть настолько понятной, чтобы пользователь, никогда раньше не видевший ее, но хорошо разбирающийся в предметной области, мог без помощи инструкторов начать ее использовать.

Это правило, в основном, служит лишь указанием идеала, к которому надо стремиться, поскольку на практике достичь такой понятности почти никогда не удается.

### Правило эффективности.

Система не должна препятствовать эффективной работе опытных пользователей, работающих с ней долгое время. Очевидным примером нарушения этого правила является нацеленность системы только на новичков.

### Правило непрерывного движения вперед.

Система должна способствовать непрерывному росту знаний, умений и навыков пользователя и приспосабливаться к его меняющемуся опыту.

Плохие результаты приносит предоставление только базовых возможностей или оставление начинающего пользователя наедине со сложными воможностями, которыми уверенно пользуются эксперты. Нарушение непрерывности при переходе от одного набора возможностей к другому также приносит неудобства, поскольку пользователь вынужден разбираться с добавленными возможностями в новом контексте.

### Правило поддержки.

Система должна способствовать более простому и быстрому решению задач пользователя.
Это означает, прежде всего, что система должна действительно решать задачи пользователя. Во-вторых, она должна решать их лучше, проще и быстрее, чем имевшиеся до ее появления методы.

### Правило соблюдения контекстов.

Система должна быть согласована со средой, в которой ей предстоит работать.
Это правило требует от системы быть работоспособной не «вообще», а именно в том окружении, в котором ею будут пользоваться. В контекст могут входить специфика и объемы входных и выходных данных, тип и цели организаций, в которых система должна работать, уровень пользователей, и пр.

Представленные правила определяют общие требования к разрабатываемому интерфейсу. Как можно действовать, чтобы соблюсти эти требования, в общих чертах можно усвоить на основе следующих принципов.

### Принцип структуризации.

Пользовательский интерфейс должен быть целесообразно структурирован. Родственные его части должны быть связаны, а независимые — разделены, похожие элементы должны выглядеть похоже, а непохожие — различаться.

### Принцип простоты.

Наиболее распространенные операции должны выполняться максимально просто. При этом должны быть ясные ссылки на более сложные процедуры.

### Принцип видимости.

Все функции и данные, необходимые для выполнения определенной задачи, должны быть видны, когда пользователь пытается ее выполнить.

### Принцип обратной связи.

Пользователь должен получать сообщения о действиях системы и о важных событиях внутри нее. Сообщения должны быть краткими, однозначными и написанными на языке, понятном пользователю.

### Принцип толерантности.

Интерфейс должен быть гибким и терпимым к ошибкам пользователя. Ущерб от ошибок должен снижаться за счет возможности отмены и повтора действий и за счет разумной интерпретации любых разумных действий и данных. По возможности, следует избегать модального взаимодействия.

### Принцип повторного использования.

Следует стараться использовать многократно внутренние и внешние компоненты, способствуя тем самым унифицированности интерфейса. Одним из наиболее технологичных подходов к разработке удобного пользовательского интерфейса ПО является проектирование, ориентированное на использование (usage-centered design), предложенной Л. Константайном и Л. Локвуд (L. Constantine, L. Lockwood).
Основной идей этого подхода является использование специальных моделей, ориентированных на описание и анализ использования ПО. Главная цель таких моделей — получить представление о том, какие задачи пользователи решают с помощью данного ПО и как должна быть организована информация для обеспечения решения этих задач.

Список моделей, с помощью которых предалагется проектировать пользовательский интерфейс, представлен ниже.

## Модель ролей.

Эта модель дает список ролей пользователей системы, каждая из которых представляет собой абстрактную группу задач и нужд некоторого множества пользователей. Ролевая модель может определять связи между ними 

- по уточнению
- по включению
- по сходству — и набор из одной-двух-трех центральных ролей, на которых, в основном, и будет нацелено проектирование

Кроме того, каждая роль может быть снабжена профилями, указывающими различные ее характеристики по отношению к контексту использования системы. Профили могут быть следующими.

**Обязанности** — требования к знаниям (о предметной области, о самой системе и прочим), которым пользователь в данной роли, скорее всего, удовлетворяет.

**Умения** — уровень мастерства в работе с системой.

**Взаимодействия** — типичные варианты взаимодействия с системой, включая их частоту, регулярность, непрерывность, концентрацию, интенсивность, сложность, предсказуемость, управление взаимодействием.

**Информация** — источники, объем, направление передачи и сложность информации при взаимодействии с системой

**Критерии удобства** — специфические критерии удобства работы для данной роли (быстрота реакции, точность указаний, удобство навигации и пр.).

**Функции** — специфические функции, возможности и свойства системы, необходимые или полезные для данной роли.

**Другие** — возможные убытки от ошибок, риски и пр.

# Билет 21. Модели пользовательского интерфейса

Основной идей этого подхода является использование специальных моделей, ориентированных на описание и анализ использования ПО. Главная цель таких моделей — получить представление о том, какие задачи пользователи решают с помощью данного ПО и как должна быть организована информация для обеспечения решения этих задач.

Список моделей, с помощью которых предалагется проектировать пользовательский интерфейс, представлен ниже.

## Модель ролей.

Эта модель дает список ролей пользователей системы, каждая из которых представляет собой абстрактную группу задач и нужд некоторого множества пользователей. Ролевая модель может определять связи между ними — по уточнению, по включению, по сходству — и набор из одной-двух-трех центральных ролей, на которых, в основном, и будет нацелено проектирование.

Кроме того, каждая роль может быть снабжена профилями, указывающими различные ее характеристики по отношению к контексту использования системы. Профили могут быть следующими.

**Обязанности** — требования к знаниям (о предметной области, о самой системе и прочим), которым пользователь в данной роли, скорее всего, удовлетворяет.

**Умения** — уровень мастерства в работе с системой.

**Взаимодействия** — типичные варианты взаимодействия с системой, включая их частоту, регулярность, непрерывность, концентрацию, интенсивность, сложность, предсказуемость, управление взаимодействием.

**Информация** — источники, объем, направление передачи и сложность информации при взаимодействии с системой

**Критерии удобства** — специфические критерии удобства работы для данной роли (быстрота реакции, точность указаний, удобство навигации и пр.).

**Функции** — специфические функции, возможности и свойства системы, необходимые или полезные для данной роли.

**Другие** — возможные убытки от ошибок, риски и пр.

## Модель задач.

Модель задач, которую можно использовать для проектированяи пользовательского интерфейса, строится на основе сценариев или вариантов использования (use cases), в которых остаются только цели и задачи пользователя в рамках данного варианта, и нет неявных предположений о наличии определенных интефейсов между пользователями и системой. Удобно описывать такие сценарии в виде двух наборов — устремлений пользователя (не действий, а задач которые он хочет решить) и обязательств системы в ответ на эти устремления.

Так, например, сценарий работы пользователя с банкоматом выглядит в обычной записи и в нацеленной на выделение задач так.

В результате модель задач представляет собой набор переработанных вариантов использования со связями между ними по расширению и по использованию. Всякая пользовательская роль должна быть поддержана одним или несколькими вариантами использования.

## Модель содержимого.
Модель содержимого пользовательского интерфейса описывает набор взаимосвязанных контекстов взаимодействия или рабочих пространств (представляемых экранами, формами, окнами, диалогами, страницами и пр.) с содержащимися в них данными и возможными в их рамках действиями.

При построении этой модели важно определить что войдет в состав интерфейса и не решать вопрос о том, как оно будет выглядеть. На начальном этапе один контекст взаимодействия ставится в соответствие одному (не вспомогательному!) варианту использования или группе очень походих вариантов, для выполнения которых понадобится один набор инструментов.
Средства для поддержки вспомогательных расширяющих вариантов использования обычно удобно  помещать в контексты расширяемых ими основных вариантов.

Сначала определяется, какая информация должна находится в заданном контексте для успешного решения задач соответствующего варианта использования, затем определяется список необходимых операций с этой информацией. После определения набора контекстов и их информационного и функционального содержимого рисуется карта навигации между контекстами. После разработки модели содержимого всякий основной вариант использования должен быть поддержан при помощи одного или нескольких контекстов.

Перечисленные три модели — ролей, задач и содержимого — являются основными. Оставшиеся две модели используются не всегда.


# Билет 24. Качество ПО

Как проверить, что требования заданы достаточно полно и описывают все, что хотелось бы видеть в будущей программной системе? Для этого служит понятие качества ПО. Именно понятие качественного ПО соответствует представлению о том, что программа достаточно успешно справляется со всеми возложенными на нее задачами и не приносит проблем ни конечным пользователям, ни их начальству, ни службе поддержки, ни специалистам по продажам.

Если попросить группу людей высказать своё мнение по поводу того, что такое качественное ПО, можно получить следующие варианты ответов.

- Его легко использовать
- Оно демонстрирует хорошую производительность
- В нем нет ошибок
- Оно не портит пользовательские данные при сбоях
- Его можно использовать на разных платформах
- Оно может работать 24 часа в сутки и 7 дней в неделю
- В него легко добавлять новые возможности
- Оно удовлетворяет потребности пользователей
- Оно хорошо документировано

Все это действительно имеет непосредственное отношение к качеству ПО. Но все эти ответы выделяют характеристики, важные для конкретного пользователя, разработчика или группы таких лиц. Для того, чтобы удовлетворить потребности всех заинтересованных сторон (конечных пользователей, заказчиков, разработчиков, администраторов систем, в
которых оно будет работать, регулирующих организаций и пр), для достижения прочного положения разрабатываемого ПО на рынке и повышения потенциала его развития важен учет  всей совокупности характеристик ПО, важных для всех заинтересованных лиц.

Приведенные выше ответы показывают, что качество ПО может быть описано большим набором разнородных характеристик. Такой подход к описанию сложных понятий называется холистическим (от греческого ολοσ, целое). Он не дает единой концептуальной основы для рассмотрения затрагиваемых вопросов, какую дает целостная система представлений (например, Ньтоновская механика в физике или классическая теория
вычислимости на основе машин Тьюринга), но позволяет, по крайней мере, не упустить ничего достаточно важного. 

### Методы контроля качества
Как контролировать качество системы? Как точно узнать, что программа делает именно то, что нужно, и ничего другого? Как определить, что она достаточно надежна, переносима, удобна в использовании? Ответы на этот вопрос можно получить с помощью процессов верификации и валидации.

**Верификация** обозначает проверку того, что продукт делался правильно, т.е. проверку того, что он разрабатывался в соответствии со всеми требованиями по отношению к процессу и этапам разработки. К верификации относятся все проверки соответствия результатов некоторого этапа разработки требованиям, выдвинутым к ним на предыдущем этапе.

**Валидация** — это проверка того, что сам продукт правилен, т.е. подтверждение того, что он действительно удовлетворяет требованиям и ожиданиям пользователей, заказчиков и других заинтересованных сторон.

Эффективность верификации и валидации, как и эффективность разработки ПО в целом зависит от точности и корректности формулировки требований к программному продукту.

Основой любой системы обеспечения качества являются методы его обеспечения и контроля. Методы обеспечения качества представляют собой техники, гарантирующие достижение определенных показателей качества при их применении. 

Методы контроля качества предназначены для того, чтобы убедиться, что
определенные характеристики качества ПО достигнуты. Сами по себе они не могут помочь их достижению, они лишь помогают определить, удалось ли получить в результате то, что хотелось, или нет, а также найти ошибки, дефекты и отклонения от требований.  

Методы контроля качества ПО можно классифицировать следующим образом.

1. Методы и техники, связанные выяснением свойств ПО во время его работы. Это, прежде всего, все виды тестирования, а также профилирование и измерение количественных показателей качества, которые можно определить по результатам работы ПО — эффективности по времени и другим ресурсам, надежности, доступности и пр.
2. Методы и техники, связанные с определением показателей качества на основе симуляции работы ПО с помощью моделей разного рода. К этому виду относятся проверка на моделях (model checking), а также прототипирование (макетирование), использованное для оценки качества принимаемых решений.
3. Методы и техники, предназначенные для выявления нарушений формализованных правил построения исходного кода ПО, проектных моделей и документации. К методам такого рода относится инспектирование кода, заключающееся в целенаправленном поиске определенных дефектов и нарушений требований в коде на основе набора шаблонов, автоматизированные методы поиска ошибок в коде, не основанные на его интерпретации, методы проверки документации на согласованность и соответствие стандартам.
4. Методы и техники, связанные с обычным или формализованным анализом проектной документации и исходного кода для выявления их свойств. К этой группе относятся многочисленные методы анализа архитектуры ПО, о которых пойдет речь в следующей лекции, методы формального доказательства свойств ПО и формального анализа
эффективности применяемых алгоритмов.

# Билет 25. Эволюция методов обеспечения качества

На разных этапах развития товарного производства применялись различные методы обеспечения качества. Выделяют три основные фазы эволюции методов обеспечения качества:

- Фаза отбраковки
- Фаза управления качеством
- Фаза планирования качества

**Фаза отбраковки**

**Концепция фазы отбраковки** состоит в том, что потребитель должен получать только годные изделия, т.е. изделия, соответствующие стандартам. 

Основные усилия должны быть направлены на то, чтобы не годные изделия (брак) были бы отсечены от потребителя. Результат фазы состоял в том, что численность контролеров стала составлять до 30 -40% от численности производственных рабочих, иногда и более. Повышение качества всегда сопровождается ростом затрат на его обеспечение. Т.е. цели повышения эффективности производства и повышения качества изделий являются противоречивыми (не могут быть достигнуты одновременно).

**Фаза управления качеством**

*Цель фазы управления качеством* – сосредоточить усилия не на том, как обнаружить и изъять негодные изделия до их отгрузки покупателю, а на том, как увеличить выход годных изделий в техпроцессе. В этой фазе выделяют два этапа:

- Управление процессами – переход от контроля к управлению отдельными процессами
- Управление производством – переход от управления отдельными процессами к управлению производством в целом

**Фаза менеджмента качества** связана с повышением качества путем управления предприятием. 

Составными элементами этого этапа являются:

- Совершенствование системы в целом, а не только отдельных производственных процессов.
- Непосредственное участии высшего руководства компаний в проблемах качества.
- Обучение всех сотрудников компаний сверху донизу основным методам обеспечения качества.
- Упор на мотивацию сотрудников на высококачественный труд .
- Концепция «0 дефектов на всех участках".

**Основная идея программы:**  "Основа качества продукции – качество труда и качественный менеджмент на всех уровнях, то есть такая организация работы коллективов людей, когда каждый работник получает удовольствие от своей работы". 

Сложилась концепция стандартизованного качества – качество определяет
производитель, а покупатель берет товар или не берет. Внутренним противоречием этой фазы **является вопрос**: что делать при ошибке определения запросов, когда годные товары не находят спроса?

**Фаза планирования качества**

*Цель* – планирование запросов. Эта фаза стала зарождаться в середине 60х гг. как развитие идей предыдущей фазы в направлении более полного удовлетворения запросов потребителей.

Предпосылками возникновения фазы планирования качества являются:

- Развитие мирового рынка товаров и услуг.
- Резкое обострение конкуренции на этом рынке.
- Политика государственной защиты интересов потребителей .
- Развитие теории надежности изделий.
- Внедрение вычислительной техники и САПР.

**Основы концепции новой фазы:**

- Большая часть дефектов изделий закладывается на стадии разработки из-за недостаточного качества проектных работ.
- Математическое моделирование свойств и процессов. Перенос центра тяжести работ по созданию изделия с натурных испытаний опытных образцов или партий на математическое моделирование свойств изделий, а также моделирование процессов производства изделий, что позволяет обнаружить и устранить конструкторские и технологическое дефекты еще до начала стадии производства.
- Снижение цены – высокое качество необходимо предоставить потребителю за приемлемую цену, которая постоянно снижается, т.к. конкуренция на рынках очень высока.

В настоящее время эта фаза только зарождается, и ее концепция еще окончательно не сформировалась.

# Билет 26. Характеристики качества программного обеспечения

**Функциональность**. Способность ПО в определенных условиях решать задачи, нужные пользователям. Определяет, что именно делает ПО, какие задачи оно решает.

**Функциональная пригодность** (suitability). Способность решать нужный набор задач.

**Точность** (accuracy). Способность выдавать нужные результаты. Способность к взаимодействию (interoperability). Способность взаимодействовать с нужным набором других систем.

**Соответствие стандартам и правилам** (compliance). Соответствие ПО имеющимся индустриальным стандартам, нормативным и законодательным актам, другим регулирующим нормам. 

**Защищенность** (security). Способность предотвращать неавторизированный, т.е. без указания лица, пытающегося его осуществить, и не разрешенный доступ к данным и программам.

**Надежность** (reliability) Способность ПО поддерживать определенную работоспособность в заданных условиях.

**Зрелость, завершенность** (maturity). Величина, обратная к частоте отказов ПО.

**Устойчивость к отказам** (fault tolerance) Способность поддерживать заданный уровень работоспособности при отказах и нарушениях правил взаимодействия с окружением.

**Способность к восстановлению** (recoverability). Способность восстанавливать определенный уровень работоспособности и целостность данных после отказа, необходимые для этого время и ресурсы.

**Соответствие стандартам надежности** (reliability compliance). Этот атрибут добавлен в 2001 году.

**Удобство использования** (usability) или практичность. Способность ПО быть удобным в обучении и использовании, а также привлекательным для пользователей.

**Понятность** (understandability). Показатель, обратный к усилиям, затрачиваемым пользователями, чтобы воспринять набор понятий, на которых основано ПО, и их применимость для решения своих задач.

**Удобство обучения** (learnability). Показатель, обратный к усилиям, затрачиваемым пользователями чтобы научиться работе с ПО.

**Удобство работы** (operability). Показатель, обратный к усилиям, предпринимаемым пользователями, чтобы решать свои задачи с помощью ПО.

**Привлекательность** (attractiveness). Способность ПО быть привлекательным для пользователей. Этот атрибут добавлен в 2001.

**Соответствие стандартам удобства использования** (usability compliance). Этот атрибут добавлен в 2001.

**Производительность** (efficiency) или эффективность. Способность ПО при заданных условиях обеспечивать необходимую работоспособность по отношению к выделяемым для этого ресурсам. Можно определить ее и как отношение получаемых с помощью ПО результатов к затрачиваемым на это ресурсам.

**Временная эффективность** (time behaviour). Способность ПО выдавать ожидаемые результаты, а также обеспечивать передачу необходимого объема данных за отведенное время.

**Эффективность использования ресурсов** (resource utilisation). Способность решать нужные задачи с использованием определенных объемов ресурсов определенных видов. Имеются в виду такие ресурсы, как оперативная и долговременная память, сетевые соединения, устройства ввода и вывода, и пр.

**Соответствие стандартам производительности** (efficiency compliance). 

**Удобство сопровождения** (maintainability) Удобство проведения всех видов деятельности, связанных с сопровождение программ.

**Анализируемость** (analyzability) или удобство проведения анализа. Удобство проведения анализа ошибок, дефектов и недостатков, а также удобство анализа на предмет необходимых изменений и их возможных эффектов. 

**Удобство внесения изменений** (changeability). Показатель, обратный к трудозатратам на проведение необходимых изменений.

**Стабильность** (stability). Показатель, обратный к риску возникновения неожиданных эффектов при внесении необходимых изменений.

**Удобство проверки** (testability). Показатель, обратный к трудозатратам на проведение тестирования и других видов проверки того, что внесенные изменения привели к нужным эффектам.

**Соответствие стандартам удобства сопровождения** (maintainability compliance).

**Переносимость** (portability). Способность ПО сохранять работоспособность при переносе из одного окружения в другое, включая организационные, аппаратные и программные аспекты окружения. Иногда
эта характеристика называется в русскоязычной литературе мобильностью. Однако термин «мобильность» стоит зарезервировать для перевода «mobility» — способности ПО и компьютерной системы в целом сохранять работоспособность при ее физическом перемещении в пространстве.

**Адаптируемость** (adaptability). Способность ПО приспосабливаться к различным окружениям без проведения для этого действий, помимо заранее предусмотренных.

**Удобство установки** (installability). Способность ПО быть установленным или развернутым в определенном окружении. 

**Способность к сосуществованию** (coexistence). Способность ПО сосуществовать с другими программами в общем окружении, деля с ним ресурсы.

**Удобство замены** (replaceability) другого ПО данным. Способность ПО
использоваться вместо другого ПО для решения тех же самых задач в заданном окружении. 

**Соответствие стандартам переносимости** (portability compliance).

**Для описания качества ПО при использовании стандарт ISO 9126-4 предлагает следующий набор характеристик.**

- Эффективность (effectiveness). Это способность ПО предоставлять пользователям возможность решать их задачи с необходимой точностью при использовании в заданном контексте.
- Продуктивность (productivity). Способность ПО предоставлять пользователям определенные результаты в рамках ожидаемых затрат ресурсов.
- Безопасность (safety). Способность ПО обеспечивать необходимо низкий уровень риска нанесения ущерба жизни и здоровью людей, бизнесу, собственности или окружающей среде.
- Удовлетворенность (satisfaction). Способность ПО приносить удовлетворение пользователям при использовании в заданном контексте.

# Билет 27. Схема процесса тестирования. Виды тестирования

Тестирование — это проверка соответствия ПО требованиям, осуществляемая с помощью наблюдения за его работой в специальных, искусственно построенных ситуациях.

Такого рода ситуации называют тестовыми или просто тестами.
Тестирование — конечная процедура. Набор ситуаций, в которых будет проверяться тестируемое ПО всегда конечен. Более того, он должен быть настолько мал, чтобы тестирование можно было провести в рамках проекта разработки ПО, не слишком увеличивая его бюджет и сроки. Это означает, что при тестировании всегда проверяется очень небольшая доля всех возможных ситуаций. По этому поводу Дейкстра (Dijkstra) сказал, что тестирование позволяет точно определить, что ошибка есть в программе, но никогда не позволяет утверждать, что там нет ошибок.

Тем не менее, тестирование может использоваться для достаточно уверенного вынесения оценок о качестве ПО. Для этого необходимо иметь критерии полноты тестирования, описывающие важность различных ситуаций для оценки качества, а также эквивалентности и зависимости между ними (т.е. все равно в какой из ситуаций, A или B, проверять правильность работы ПО, или, если программа правильно работает в ситуации A, то, скорее всего, в ситуации B все тоже будет правильно). Часто критерий полноты тестирования задается при помощи определения эквивалентности ситуаций, дающей конечный набор классов ситуаций. В этом случае считают, что все равно, какую из ситуаций одного класса использовать в качестве теста. Такой критерий называют критерием тестового покрытия, а процент классов эквивалентности ситуаций, покрытых во время тестирования — достигнутым тестовым покрытием.

Таким образом, основные задачи тестирования — построить такой набор ситуаций, который был бы достаточно представителен и позволял бы завершить тестирование с достаточной степенью уверенности в правильности проверяемого ПО вообще, и убедиться, что в конкретной ситуации ПО работает правильно, в соответствии с требованиями.

Тестировать можно соблюдение любых требований, соответствие которым выявляется во время работы ПО. Из характеристик качества по ISO 9126 этим свойством не обладают только атрибуты удобства сопровождения. Поэтому выделяют виды тестирования, связанные с проверкой определенных характеристик и атрибутов качества — тестирования
функциональности, надежности, удобства использования, переносимости и
производительности, а также тестирование защищенности, функциональной пригодности и пр. Кроме того, особо выделяют нагрузочное или стрессовое тестирование, проверяющее работоспособность ПО и показатели его производительности в условиях повышенных нагрузок — большом количестве пользователей, интенсивном обмене данными с другими
системами, большим объемом передаваемых или используемых данных, и пр.

На основе исходных данных, используемых для построения тестов, тестирование делят на следующие виды.

1. Тестирование на соответствие (conformance testing) — тесты для него и критерий полноты тестирования строятся на основе каких-то достаточно четко зафиксированных требований (в спецификациях, стандартах, внутренних нормативных документах). Частным случаем является функциональное тестирование, оно же тестирование черного ящика —
тесты для него, а также используемые критерии полноты проведенного тестирования определяют на основе требований к функциональности. Частным случаем тестирования на соответствие является аттестационное или квалификационное тестирование, по результатам которого программная система получает (или не получает) официальный документ, подтверждающий ее соответствие определенным требованиям и стандартам.

2. Структурное тестирование, оно же тестирование белого ящика — тесты создаются на основе знаний о структуре самой системы и о том, как она работает. Критерии полноты основаны на проценте элементов кода, которые отработали в ходе выполнения тестов. Для оценки степени соответствия требованиям могут привлекаться дополнительные знания о прослеживании требований в определенные ограничения на значения внутренних данных системы (например, на значения параметров вызовов, результатов и локальных переменных).

3. Тестирование, нацеленное на определенные ошибки. Тесты для такого
тестирования строятся так, чтобы гарантированно выявлять определенные виды ошибок. Полнота тестирования определяется на основе количества проверенных ситуаций по отношению к общему числу ситуаций, которые мы пытались достичь. К этому виду относится, например, тестирование на отказ (smoke testing), в ходе которого просто пытаются вывести систему из строя, давая ей на вход как обычные данные, так и некорректные, с нарочно внесенными ошибками. Другим примером служит метод оценки
полноты тестирования при помощи набора мутантов — программ, совпадающих с тестируемой всюду, кроме нескольких мест, где специально внесены некоторые ошибки. Чем больше мутантов тесты находят, тем полнее проводимое с их помощью тестирование. Еще одна классификация видов тестирования основана на том уровне, на который оно нацелено. Эти же разновидности тестирования можно связать с фазой жизненного цикла, на которой они выполняются.

1. Модульное тестирование (unit testing) предназначено для проверки правильности отдельных модулей, вне зависимости от их окружения. При этом проверяется, что, если модуль получает на вход данные, удовлетворяющие определенным критериям корректности, то и результаты его корректны. Для описания критериев корректности входных и выходных данных часто используют программные контракты — предусловия, описывающие для каждой операции, на каких входных данных она предназначена работать, постусловия, описывающие для каждой операции, как должны соотноситься входные данные с возвращаемыми ею результатами, и инварианты, определяющие критерии целостности внутренних данных модуля. Модульное тестирование является важной составной частью отладочного тестирования, выполняемого разработчиками для отладки написанного ими кода.

2. Интеграционное тестирование (integration testing) предназначено для проверки правильности взаимодействия модулей некоторого набора друг с другом. При этом проверяется, что в ходе совместной работы модули обмениваются данными и вызовами операций, не нарушая взаимных ограничений на такое взаимодействие, например, предусловий вызываемых операций. Интеграционное тестирование также используется при отладке, но на более позднем этапе разработки.

3. Системное тестирование (system testing) предназначено для проверки правильности работы системы в целом, ее способности правильно решать поставленные пользователями задачи в различных ситуациях. Системное тестирование тесно связано с тестированием пользовательского интерфейса (или через пользовательский интерфейс), проводимым при помощи имитации действий пользователей над элементами этого интерфейса. Частными случаями этого вида тестирования являются тестирование графического пользовательского интерфейса (Graphical User Interface, GUI) и пользовательского интерфейса Интернет-приложений (Web UI). Если интеграционное и модульное тестирование чаще всего проводят, воздействуя на компоненты системы при помощи операций предоставляемого ими программного интерфейса (Application Programming
Interface, API), то на системном уровне без использования пользовательского интерфейса не обойтись, хотя тестирование через API в этом случае также часто возможно.

4. Проверка свойств на моделях (model checking) [10] — проверка соответствия ПО требованиям при помощи формализации проверяемых свойств, построения формальных моделей проверяемого ПО (чаще всего в виде автоматов различных видов) и автоматической проверки выполнения этих свойств на построенных моделях. Проверка свойств на моделях позволяет проверять достаточно сложные свойства автоматически, при минимальном участии человека. Однако она оставляет открытым вопрос о том, насколько выявленные свойства модели можно переносить на само ПО.

# Билет 28. Идеология структурного анализа. SADT диаграммы.

Суть структурного підходу до розробки ІС полягає в її декомпозиції (розбитті) на функції, що автоматизуються: система розбивається на функціональні підсистеми, які у свою чергу діляться на підфункції, що підрозділяються на завдання і так далі. Процес розбиття продовжується аж до конкретних процедур. При цьому система, що автоматизується, зберігає цілісне уявлення, в якому всі компоненти, що становлять, взаємопов'язані. При розробці системи "знизу-вгору" від окремих завдань до всієї системи цілісність втрачається, виникають проблеми при інформаційній стиковці окремих компонентів. 

Всі найбільш поширені методології структурного підходу базуються на ряду загальних принципів. Як два базові принципи використовуються наступні: 

- принцип "розділяй і володарюй"; 
- принцип ієрархічного впорядковування.

Виділення двох базових принципів не означає, що решта принципів є другорядними, оскільки ігнорування будь-якого з них може привести до непередбачуваних наслідків (у тому числі і до провалу всього проекту). 

Основними з цих принципів є наступні: 

- принцип абстрагування; 
- принцип формалізації; 
- принцип несуперечності; 
- принцип структуризації даних.

У структурному аналізі використовуються в основному дві групи засобів, що ілюструють функції, що виконуються системою і відносини між даними. Кожній групі засобів відповідають певні види моделей (діаграм), найбільш поширеними серед яких є наступні: 

- **SADT** (Structured Analysis and Design Technique) моделі і відповідні функціональні діаграми; 
- **DFD** (Data Flow Diagrams) діаграми потоків даних; 
- **ERD** (Entity-Relationship Diagrams) діаграми "суть-зв'язок".

На стадии проектирования ИС модели расширяются, уточняются и дополняются диаграммами, отражающими структуру программного обеспечения: архитектуру ПО, структурные схемы программ и диаграммы экранных форм. 

**Метод SADT**

Методологія SADT розроблена Дугласом Россом, на її основі розроблена, зокрема, відома методологія IDEF0 (Icam DEFinition), яка є основною частиною програми ICAM (Інтеграція комп'ютерних і промислових технологій), що проводиться за ініціативою ВВС США.  

Методологія SADT є сукупністю методів, правив і процедур, призначених для побудови функціональної моделі об'єкту якої-небудь наочної області. Функціональна модель SADT відображає функціональну структуру об'єкту, тобто вироблювані ним дії і зв'язки між цими діями. Основні елементи цієї методології грунтуються на наступних концепціях: 

- графічне представлення блокового моделювання. Графіка блоків і дуг SADT-диаграммы відображає функцію у вигляді блоку, а інтерфейси входу/виходу представляються дугами, що відповідно входять в блок і виходять з нього. Взаємодія блоків один з одним описуються за допомогою інтерфейсних дуг, що виражають "обмеження", які у свою чергу визначають, коли і яким чином функції виконуються і управляються; 
- строгість і точність. Виконання правив SADT вимагає достатньої строгості і точності, не накладаючи в той же час надмірних обмежень на дії аналітика. 

**Правила SADT включають:** 
- обмеження кількості блоків на кожному рівні декомпозиції; 
- зв'язність діаграм; 
- унікальність влучний і найменувань; 
- синтаксичні правила для графіки; 
- розділення входів і управлінь. 
- відділення організації від функції, тобто виключення впливу організаційної структури на функціональну модель.

**Склад функціональної моделі**

Результатом застосування методології SADT є модель, яка складається з діаграм, фрагментів текстів і глосарію, що мають посилання один на одного. 

**Діаграми** – головні компоненти моделі, всі функції ІС і інтерфейси на них представлені як блоки і дуги. *Місце з'єднання дуги* з блоком визначає тип інтерфейсу. Інформація, що управляє, входить в блок зверху, тоді як інформація, яка піддається обробці, показана з лівого боку блоку, а результати виходу показані з правого боку. *Механізм* (людина або автоматизована система), який здійснює операцію, представляється дугою, що входить в блок знизу (рис 9.1). 

**Типи зв'язків між функціями**

Одним з важливих моментів при проектуванні ІС за допомогою методології SADT є точна узгодженість типів зв'язків між функціями. Розрізняють принаймні сім типів скріплення: 

| Значущість | Тип зв'язності | Для функцій | Для даних |
|-|-|-|-|
| 0 | Випадкова  | Випадкова | Випадкова|
| 1 | Логічна | Функції однієї і тієї ж множини або типу (наприклад, "редагувати всі входи") | Дані однієї і тієї ж множини або типу |
| 2 | Тимчасова  | Функції одного і того ж періоду часу (наприклад,  "операції ініціалізації")  | Дані, використовувані в якому-небудь тимчасовому інтервалі |
| 3 | Процедурна  | Функції, що працюють в одній і тій же фазі або ітерації (наприклад, "перший прохід компілятора")  | Дані, використовувані під час однієї і тієї ж фази або ітерації |
| 4 | Коммуникационнная | Функції, що використовують одні і ті ж дані  | Дані, на які впливає одна і та ж діяльність |
| 5 | Послідовна  | Функції, що виконують послідовні перетворення одних і тих же даних  | Дані, що перетворюються послідовними функціями |
| 6 | Функціональна | Функції, що об'єднуються для виконання однієї функції  | Дані, пов'язані з однією функцією |

# Билет 29. Структурный подход к проектированию ПО – DFD диаграммы. Діаграми потоків даних

У основі даної методології (методології Gane/Sarson) лежить побудова моделі аналізованої ІС – проектованою або такою, що реально існує. Відповідно до методології модель системи визначається як ієрархія діаграм потоків даних (ДПД або DFD), що описують асинхронний процес перетворення інформації від її введення в систему до видачі користувачеві. Діаграми верхніх рівнів ієрархії визначають основні процеси або підсистеми ІС із зовнішніми входами і виходами. Вони деталізують за допомогою діаграм нижнього рівня. Така декомпозиція продовжується, створюючи багаторівневу ієрархію діаграм, до тих пір, поки не буде досягнутий такий рівень декомпозиції, на якому процес стають елементарними і деталізувати їх далі неможливо. 

**Джерела інформації** (зовнішня суть) породжують інформаційні потоки (потоки даних), що переносять інформацію до підсистем або процесів. Ті у свою чергу перетворять інформацію і породжують нові потоки, які переносять інформацію до інших процесів або підсистем, накопичувачів даних або зовнішньої суті – споживачів інформації. Таким чином, основними компонентами діаграм потоків даних є: 

- зовнішня суть; 
- системи/підсистеми; 
- процеси; 
- накопичувачі даних; 
- потоки даних.

**Зовнішня сущність**

**Зовнішня суть** є матеріальним предметом або фізичною особою, що є джерелом або приймачем інформації. В процесі аналізу деяка зовнішня суть може бути перенесені всередину діаграми аналізованої ІС, якщо це необхідно, або, навпаки, частина процесів ІС може бути винесена за межі діаграми і представлена як зовнішня суть. 

Зовнішня сущність позначається квадратом (рис.9.8), розташованим як би "над" діаграмою і що кидає на неї тінь, для того, щоб можна було виділити цей символ серед інших позначень: 

**Системи і підсистеми**

При построении модели сложной ИС она может быть представлена в самом общем виде на так называемой контекстной диаграмме в виде одной системы как единого целого, либо может быть декомпозирована на ряд подсистем. 

**Підсистема** (або система) на контекстній діаграмі зображається таким чином (рис. 9.2). 

Номер підсистеми служить для її ідентифікації. У поле імені вводиться найменування підсистеми у вигляді пропозиції з підметом і відповідними визначеннями і доповненнями. 

**Процеси**

Процесом є перетворення вхідних потоків даних у вихідні відповідно до певного алгоритму. Процес на діаграмі потоків даних зображається, як показано на рис. 8.10. 

Номер процесу служить для його ідентифікації. У поле імені вводиться найменування процесу у вигляді пропозиції з активним недвозначним дієсловом в невизначеній формі (обчислити, розрахувати, перевірити, визначити, створити, отримати), за яким слідують іменники в знахідному відмінку, наприклад: 

- "Ввести відомості про клієнтів"; 
- "Видати інформацію про поточні витрати"; 
- "Перевірити кредитоспроможність клієнта".

Інформація в полі фізичної реалізації показує, який підрозділ організації, програма або апаратний пристрій виконує даний процес.

**Накопичувачі даних**

Накопичувачем даних є абстрактний пристрій для зберігання інформації, яку можна у будь-який момент помістити в накопичувач і через деякий час витягувати, причому способи приміщення і витягання можуть бути будь-якими. 

Накопичувач даних ідентифікується буквою "D" і довільним числом. Ім'я накопичувача вибирається з міркування найбільшої інформативності для проектувальника. 

**Потоки даних**

Поток данных определяет информацию, передаваемую через некоторое соединение от источника к приемнику. Поток данных на диаграмме изображается линией, оканчивающейся стрелкой, которая показывает направление потока (рис.8.12). Каждый поток данных имеет имя, отражающее его содержание. 

# Билет 30. Управление программным проектом – Сетевой график выполнения работ.

## Управление проектами 

Управление проектами — в соответствии с определением национальным стандартом ANSI PMBoK — область деятельности, в ходе которой определяются и достигаются четкие цели проекта при балансировании между объёмом работ, ресурсами (такими как деньги, труд, материалы, энергия, пространство и др.), временем, качеством и рисками. Ключевым фактором успеха проектного управления является наличие чёткого заранее определённого плана, минимизации рисков и отклонений от плана, эффективного управления изменениями (в отличие от процессного, функционального управления, управления уровнем услуг).

Продуктами проекта могут быть продукция предприятия или организации (результаты научных и маркетинговых исследований, проектно-конструкторская и технологическая документация на новое изделие, разработанные для заказчика) и решение разных внутренних производственных задач (например, повышение качества продукции и эффективности организации труда, оптимизация финансовых потоков).

Управление проектами является частью системы менеджмента предприятия.

Существует множество подходов к управлению проектами в зависимости от типа проекта[1]:

* предположение о неограниченности ресурсов, критичен только срок выполнения и качество — метод PERT, метод критического пути;
* предположение о критичности качества, при этом требования к сроку и ресурсам достаточно гибки (под качеством здесь понимается полнота удовлетворения потребностей, как известных, так и неизвестных заранее, часто создаваемых выходом нового продукта) — гибкая методология разработки;
* предположение о неизменности требований, низких рисках, жесткий срок, из этого исходят классические методы PMBOK, во многом опирающиеся на модель водопада;
* предположение о высоких рисках проекта — метод инновационных проектов.

Существуют также варианты нейтральных (сбалансированных) подходов, делающие либо акцент на взаимодействие исполнителей (метод PRINCE2), либо на взаимодействие процессов (процессно-ориентированное управление[en]).

### Цель управления проектом и успешность проекта
Успешность проекта различным образом оценивается в разных методиках. Успешность может разным образом оцениваться различными участниками проекта.

Группы оценок успешности:

* Ориентированные на контракт, например традиционные методологии, в том числе PMBOK: «проект успешен, если выполнен согласно утвержденным критериям: объёму, сроку, качеству». То есть проект успешен, если исполнен и закрыт договор между Заказчиком и Исполнителем (вне зависимости от того, являлся ли он юридическим документом в случае внешних проектов или определялся как-то иначе в случае внутренних проектов). При этом оценка успешности единая как для заказчика так и для исполнителя.
* Ориентированные на заказчика, например гибкие методологии SCRUM, частично управление программами, направленное на длительное взаимодействие, а не на один проект/контракт: «проект успешен, если заказчик удовлетворен». Здесь делается акцент на продолжение сотрудничества Исполнителя с Заказчиком в рамках последующих проектов и иного взаимодействия, либо проект можно рассматривать как программу из нескольких небольших проектов. Оценка успешности рассматривается в основном с точки зрения заказчика.
* Сбалансированные, например PRINCE2: «проект успешен при сбалансированности по крайней мере по трем категориям — бизнеса, ориентации на пользователя и технологической зрелости». Здесь делается акцент на финансовой успешности проекта, удовлетворенности пользователей и развитии (косвенная польза для самого исполнителя). Оценка успешности может различаться с точки зрения бизнеса, пользователя и исполнителя. Такие методики оценки чаще используются для внутренних проектов, когда заказчик и исполнитель находятся в одной организации.
* Так, например, проект, уложившийся в согласованные сроки и затраты, но не окупившийся по результатам проекта (затраты велики, результат неактуален к окончанию проекта, заказчик не может воспользоваться результатом и т. п.) будет успешен по традиционной методологии, но не успешен по методологии, ориентированной на заказчика. Ответственность за неуспешность такого проекта несет заказчик и, в некоторых случаях, проектный офис либо служба заказчика.

В целом можно определить цель управления проектами следующим образом:

```«Целью управления проектом(-ами) является достижение заранее определенных целей при заранее известных ограничениях и целесообразном использовании возможностей, реагировании на риски.»```

Даже при достижении поставленных целей и целесообразности изменений, проект может не соответствовать ожиданиям заинтересованных сторон. В проектах с высоким уровнем изменений требуется управление ожиданиями.

### Процедуры управления проектом по традиционной методологии
Последовательность процедур управления проектом:

* Определение среды проекта.
* Формулирование проекта.
* Планирование проекта.
* Техническое выполнение проекта (за исключением планирования и контроля).
* Контроль над выполнением проекта.

## Сетевой график

**Сетевой график** — это динамическая модель производственного процесса, отражающая технологическую зависимость и последовательность выполнения комплекса работ, увязывающая их свершение во времени с учётом затрат ре­сурсов и стоимости работ с выделением при этом узких (критических) мест.

![image](https://dl.dropboxusercontent.com/u/8382381/images/30_1.png)

### Структура

Основные элементы сетевого графика — работа и событие. Также важным понятием является понятие пути.

#### Работа
Работа отражает трудовой процесс, в котором участвуют люди, машины, механизмы, материальные ресурсы (проектирование сооружения, поставки оборудования, кладка стен, решение задач на ЭВМ и т. п.) либо процесс ожидания (твердение бетона, сушка штукатурки и т. п.). Каждая работа сетевого графика имеет конкретное содержание. Работа как трудовой процесс требует затрат времени и ресурсов, а как ожидание — только времени. Для правильного и наглядного отображения порядка предшествования работ при построении сети используют изображаемые штриховыми линиями дополнительные дуги, называемые фиктивными рабо­тами или связями. Они не требуют ни времени, ни ресурсов, а лишь указывают, что начало одной работы зависит от окончания другой.

#### Событие

Событие выражает факт окончания одной или нескольких непосредственно предшествующих (входящих в событие) работ, необходимых для начала непосредственно следующих (выходящих из события) работ. Событие, стоящее в начале работы, называется начальным, а в конце — конечным. Начальное событие сетевого графика называется исходным, а конечное — завершающим. Событие, не являющееся ни исходным, ни завершающим, называется промежуточным. В исходное событие сетевого графика не входит, а из завершающего не выходит ни одна работа. В отличие от работ, события совершаются мгновенно без потребления ресурсов.

#### Путь

Под путём понимают любую последовательность работ в сетевом графике, при которой конечное событие каждой работы совпадает с начальным событием последующей. Продолжительность пути определяется суммой продолжительностей составляющих его работ. Путь наибольшей длины между исходными и завершающими событиями называется критическим (Lm). Если критическое время не соответствует заданному или нормативному, сокращение сроков производственного процесса необходимо начинать с сокращения продолжительности критических работ.


# Билет 31.Управление программным проектом – Диаграммы Ганта.

## Управление проектами 

Управление проектами — в соответствии с определением национальным стандартом ANSI PMBoK — область деятельности, в ходе которой определяются и достигаются четкие цели проекта при балансировании между объёмом работ, ресурсами (такими как деньги, труд, материалы, энергия, пространство и др.), временем, качеством и рисками. Ключевым фактором успеха проектного управления является наличие чёткого заранее определённого плана, минимизации рисков и отклонений от плана, эффективного управления изменениями (в отличие от процессного, функционального управления, управления уровнем услуг).

Продуктами проекта могут быть продукция предприятия или организации (результаты научных и маркетинговых исследований, проектно-конструкторская и технологическая документация на новое изделие, разработанные для заказчика) и решение разных внутренних производственных задач (например, повышение качества продукции и эффективности организации труда, оптимизация финансовых потоков).

Управление проектами является частью системы менеджмента предприятия.

Существует множество подходов к управлению проектами в зависимости от типа проекта[1]:

* предположение о неограниченности ресурсов, критичен только срок выполнения и качество — метод PERT, метод критического пути;
* предположение о критичности качества, при этом требования к сроку и ресурсам достаточно гибки (под качеством здесь понимается полнота удовлетворения потребностей, как известных, так и неизвестных заранее, часто создаваемых выходом нового продукта) — гибкая методология разработки;
* предположение о неизменности требований, низких рисках, жесткий срок, из этого исходят классические методы PMBOK, во многом опирающиеся на модель водопада;
* предположение о высоких рисках проекта — метод инновационных проектов.

Существуют также варианты нейтральных (сбалансированных) подходов, делающие либо акцент на взаимодействие исполнителей (метод PRINCE2), либо на взаимодействие процессов (процессно-ориентированное управление[en]).

### Цель управления проектом и успешность проекта
Успешность проекта различным образом оценивается в разных методиках. Успешность может разным образом оцениваться различными участниками проекта.

Группы оценок успешности:

* Ориентированные на контракт, например традиционные методологии, в том числе PMBOK: «проект успешен, если выполнен согласно утвержденным критериям: объёму, сроку, качеству». То есть проект успешен, если исполнен и закрыт договор между Заказчиком и Исполнителем (вне зависимости от того, являлся ли он юридическим документом в случае внешних проектов или определялся как-то иначе в случае внутренних проектов). При этом оценка успешности единая как для заказчика так и для исполнителя.
* Ориентированные на заказчика, например гибкие методологии SCRUM, частично управление программами, направленное на длительное взаимодействие, а не на один проект/контракт: «проект успешен, если заказчик удовлетворен». Здесь делается акцент на продолжение сотрудничества Исполнителя с Заказчиком в рамках последующих проектов и иного взаимодействия, либо проект можно рассматривать как программу из нескольких небольших проектов. Оценка успешности рассматривается в основном с точки зрения заказчика.
* Сбалансированные, например PRINCE2: «проект успешен при сбалансированности по крайней мере по трем категориям — бизнеса, ориентации на пользователя и технологической зрелости». Здесь делается акцент на финансовой успешности проекта, удовлетворенности пользователей и развитии (косвенная польза для самого исполнителя). Оценка успешности может различаться с точки зрения бизнеса, пользователя и исполнителя. Такие методики оценки чаще используются для внутренних проектов, когда заказчик и исполнитель находятся в одной организации.
* Так, например, проект, уложившийся в согласованные сроки и затраты, но не окупившийся по результатам проекта (затраты велики, результат неактуален к окончанию проекта, заказчик не может воспользоваться результатом и т. п.) будет успешен по традиционной методологии, но не успешен по методологии, ориентированной на заказчика. Ответственность за неуспешность такого проекта несет заказчик и, в некоторых случаях, проектный офис либо служба заказчика.

В целом можно определить цель управления проектами следующим образом:

```«Целью управления проектом(-ами) является достижение заранее определенных целей при заранее известных ограничениях и целесообразном использовании возможностей, реагировании на риски.»```

Даже при достижении поставленных целей и целесообразности изменений, проект может не соответствовать ожиданиям заинтересованных сторон. В проектах с высоким уровнем изменений требуется управление ожиданиями.

### Процедуры управления проектом по традиционной методологии
Последовательность процедур управления проектом:

* Определение среды проекта.
* Формулирование проекта.
* Планирование проекта.
* Техническое выполнение проекта (за исключением планирования и контроля).
* Контроль над выполнением проекта.

## Диагра́мма Га́нта

![image](https://dl.dropboxusercontent.com/u/8382381/images/31_1.png)

Диагра́мма Га́нта (англ. Gantt chart, также ленточная диаграмма, график Ганта) — это популярный тип столбчатых диаграмм (гистограмм), который используется для иллюстрации плана, графика работ по какому-либо проекту. Является одним из методов планирования проектов. Используется в приложениях по управлению проектами.

Первый формат диаграммы был разработан Генри Л. Гантом в 1910 году.

По сути, диаграмма Ганта состоит из полос, ориентированных вдоль оси времени. Каждая полоса на диаграмме представляет отдельную задачу в составе проекта (вид работы), её концы — моменты начала и завершения работы, её протяженность — длительность работы. Вертикальной осью диаграммы служит перечень задач. Кроме того, на диаграмме могут быть отмечены совокупные задачи, проценты завершения, указатели последовательности и зависимости работ, метки ключевых моментов (вехи), метка текущего момента времени «Сегодня» и др.

Ключевым понятием диаграммы Ганта является «Веха» — метка значимого момента в ходе выполнения работ, общая граница двух или более задач. Вехи позволяют наглядно отобразить необходимость синхронизации, последовательности в выполнении различных работ. Вехи, как и другие границы на диаграмме, не являются календарными датами. Сдвиг вехи приводит к сдвигу всего проекта. Поэтому диаграмма Ганта не является, строго говоря, графиком работ. И это один из основных её недостатков. Кроме того, диаграмма Ганта не отображает значимости или ресурсоемкости работ, не отображает сущности работ (области действия). Для крупных проектов диаграмма Ганта становится чрезмерно тяжеловесной и теряет всякую наглядность.

Указанные выше недостатки и ограничения серьёзно ограничивают область применения диаграммы. Тем не менее, в настоящее время диаграмма Ганта является стандартом де-факто в теории и практике управления проектами, по крайней мере, для отображения Структуры перечня работ по проекту.


# Билет 32.Управление рисками проекта.

## Управление проектами 

Управление проектами — в соответствии с определением национальным стандартом ANSI PMBoK — область деятельности, в ходе которой определяются и достигаются четкие цели проекта при балансировании между объёмом работ, ресурсами (такими как деньги, труд, материалы, энергия, пространство и др.), временем, качеством и рисками. Ключевым фактором успеха проектного управления является наличие чёткого заранее определённого плана, минимизации рисков и отклонений от плана, эффективного управления изменениями (в отличие от процессного, функционального управления, управления уровнем услуг).

Продуктами проекта могут быть продукция предприятия или организации (результаты научных и маркетинговых исследований, проектно-конструкторская и технологическая документация на новое изделие, разработанные для заказчика) и решение разных внутренних производственных задач (например, повышение качества продукции и эффективности организации труда, оптимизация финансовых потоков).

Управление проектами является частью системы менеджмента предприятия.

Существует множество подходов к управлению проектами в зависимости от типа проекта[1]:

* предположение о неограниченности ресурсов, критичен только срок выполнения и качество — метод PERT, метод критического пути;
* предположение о критичности качества, при этом требования к сроку и ресурсам достаточно гибки (под качеством здесь понимается полнота удовлетворения потребностей, как известных, так и неизвестных заранее, часто создаваемых выходом нового продукта) — гибкая методология разработки;
* предположение о неизменности требований, низких рисках, жесткий срок, из этого исходят классические методы PMBOK, во многом опирающиеся на модель водопада;
* предположение о высоких рисках проекта — метод инновационных проектов.

Существуют также варианты нейтральных (сбалансированных) подходов, делающие либо акцент на взаимодействие исполнителей (метод PRINCE2), либо на взаимодействие процессов (процессно-ориентированное управление[en]).

### Цель управления проектом и успешность проекта
Успешность проекта различным образом оценивается в разных методиках. Успешность может разным образом оцениваться различными участниками проекта.

Группы оценок успешности:

* Ориентированные на контракт, например традиционные методологии, в том числе PMBOK: «проект успешен, если выполнен согласно утвержденным критериям: объёму, сроку, качеству». То есть проект успешен, если исполнен и закрыт договор между Заказчиком и Исполнителем (вне зависимости от того, являлся ли он юридическим документом в случае внешних проектов или определялся как-то иначе в случае внутренних проектов). При этом оценка успешности единая как для заказчика так и для исполнителя.
* Ориентированные на заказчика, например гибкие методологии SCRUM, частично управление программами, направленное на длительное взаимодействие, а не на один проект/контракт: «проект успешен, если заказчик удовлетворен». Здесь делается акцент на продолжение сотрудничества Исполнителя с Заказчиком в рамках последующих проектов и иного взаимодействия, либо проект можно рассматривать как программу из нескольких небольших проектов. Оценка успешности рассматривается в основном с точки зрения заказчика.
* Сбалансированные, например PRINCE2: «проект успешен при сбалансированности по крайней мере по трем категориям — бизнеса, ориентации на пользователя и технологической зрелости». Здесь делается акцент на финансовой успешности проекта, удовлетворенности пользователей и развитии (косвенная польза для самого исполнителя). Оценка успешности может различаться с точки зрения бизнеса, пользователя и исполнителя. Такие методики оценки чаще используются для внутренних проектов, когда заказчик и исполнитель находятся в одной организации.
* Так, например, проект, уложившийся в согласованные сроки и затраты, но не окупившийся по результатам проекта (затраты велики, результат неактуален к окончанию проекта, заказчик не может воспользоваться результатом и т. п.) будет успешен по традиционной методологии, но не успешен по методологии, ориентированной на заказчика. Ответственность за неуспешность такого проекта несет заказчик и, в некоторых случаях, проектный офис либо служба заказчика.

В целом можно определить цель управления проектами следующим образом:

```«Целью управления проектом(-ами) является достижение заранее определенных целей при заранее известных ограничениях и целесообразном использовании возможностей, реагировании на риски.»```

Даже при достижении поставленных целей и целесообразности изменений, проект может не соответствовать ожиданиям заинтересованных сторон. В проектах с высоким уровнем изменений требуется управление ожиданиями.

### Процедуры управления проектом по традиционной методологии
Последовательность процедур управления проектом:

* Определение среды проекта.
* Формулирование проекта.
* Планирование проекта.
* Техническое выполнение проекта (за исключением планирования и контроля).
* Контроль над выполнением проекта.

## Управление рисками проекта

На стадии инициации проекта оценка его трудоемкости имеет погрешность от -50% до +100% [4]. Это, если оценка хорошая! А если плохая, то неопределенность, а, следовательно, и риски сорвать сроки и превысить плановую трудоемкость, могут быть в разы больше. Если не прилагать специальных усилий этот «дамоклов меч» неопределенности будет висеть над проектом на всем его протяжении (Рисунок 31).

Проектом следует управлять так, чтобы риски несвоевременной сдачи и перерасхода ресурсов постоянно снижались.

Ранее мы уже говорили о том, что 80% ценности разработки обусловлена лишь 20% требований к продукту, без реализации которых продукт для заказчика становится просто ненужным. Остальные требования, как правило, так называемые «украшательства», от части которых заказчик, как правило, может отказаться, чтобы получить проект в срок. Поэтому следует в первую очередь реализовывать ключевые функциональные требования.

Но есть и еще архитектурные риски. Известно, что закон Парето применим и к потреблению вычислительных ресурсов: 80% потребления ресурсов (время и память) приходится на 20% компонентов. Поэтому, необходимо реализовывать архитектурно-значимые требования так же в первую очередь, создавая «представительный» прототип будущей системы, который «простреливает» весь стек, применяемых технологий. Прототип позволит измерить и оценить общесистемные свойства будущего продукта: доступность, быстродействие, надежность, масштабируемость и проч. (Рисунок 32)

Ошибка — реализовывать сначала легкие требования, чтобы продемонстрировать быстрый прогресс проекта.

![image](https://dl.dropboxusercontent.com/u/8382381/images/32_1.png)
Неопределенность не уменьшается, если управление не направлено на раннее разрешение рисков

### Мониторинг и контроль рисков

Управление рисками должно осуществляться на протяжении всего проекта. Не вести мониторинг рисков в ходе проекта — все равно, что не следить за уровнем топлива при поездке на автомобиле.

Мониторинг и управление рисками — это процесс идентификации, анализа и планирования реагирования на новые риски, отслеживания ранее идентифицированных рисков, а также проверки и исполнения операций реагирования на риски и оценка эффективности этих операций.

В процессе мониторинга и управления рисками используются различные методики, например, анализ трендов и отклонений, для выполнения которых необходимы количественные данные об исполнении, собранные в процессе выполнения проекта.

#### Мониторинг и управления рисками включает в себя следующие задачи:

* Пересмотр рисков.
* Аудит рисков.
* Анализ отклонений и трендов.

Главные причины провала программных проектов:

* Требования заказчика отсутствуют / не полны / подвержены частым изменениям.
* Отсутствие необходимых ресурсов и опыта.
* Отсутствие рабочего взаимодействия с заказчиком.
* Неполнота планирования. «Забытые работы».
* Ошибки в оценках трудоемкостей и сроков работ.

Отказываться от управления проектными рисками это все равно, что в кинотеатре не иметь огнетушителей и плана эвакуации на случай пожара.

Все, что мы делаем, управляя проектом разработки ПО, должно быть направлено на борьбу с рисками не уложиться в срок, перерасходовать ресурсы, разработать не тот продукт, который требуется.

# Билет 33. Компетенции руководителя проекта. 
 
Інститутом якості ПО (SQI - Software Quality Institute) розроблений керівною документ (Body of Knowledge) для сертифікації менеджерів програмних проектів (SWPM – SoftWare Project Management).  У цьому документі міститься список 34 компетенцій, якими повинен володіти менеджер програмного проекту. 

Список роздільний на три основні категорії: 

- Методика розробки продукту
- Навики управління проектів
- Навики управління персоналом 

Методика розробки продукту

1.	Процеси оцінювання - визначення критеріїв для відбору
2.	Знання стандартів процесу
3.	Визначення продукту - ідентифікація клієнтського середовища і вимог, що висуваються до продукту
4.	Оцінка альтернативних процесів
5.	Управління требованиями- моніторинг зміни вимог
6.	Управління субпідрядниками - планування, управління і здійснення контролю
7.	Виконання початкової оцінки - оцінка ступеня трудності, рисок, витрат і створення графіків
8.	Відбір методів і інструментів - визначення процесів відбору
9.	Підгонка процесів - модифікація стандартних процесів з метою задоволення вимог проектів
10.	Відстежування якості продукту - контроль якості в процесі розробки продукту
11.	Розуміння дій з розробки продукту - вивчення циклу розробки ПО
Навики управління проектів
12.	Створення структури післяопераційного переліку робіт
13.	Документування планів - ідентифікація ключових компонент
14.	Оцінка вартості - вартості завершення проекту
15.	Оцінка трудовитрат - необхідних для завершення проекту
16.	Менеджмент рисок - ідентифікація, визначення дії, обробка рисок
17.	Відстежування процесу розробки - контроль процесу розробки
18.	Складання графіка - розробка графіка і ключових стадій проекту
19.	Вибір метричних показників
20.	Відбір інструментів менеджменту проекту - вибір методик і інструментів
21.	Відстежування процесів - моніторинг сумісності членів команди
22.	Відстежування ходу розробки продукту - моніторинг ходу розробки за вибраними метричними показниками
Навики управління персоналом
23.	Оцінка продуктивності - оцінка дій команди, направлених на підвищення її продуктивності
24.	Питання інтелектуальної власності - розуміння ступеня впливу критичних проблем
25.	Організація ефективних зустрічей - планування і проведення
26.	Взаємодія і спілкування - з розробниками, керівництвом і іншими командами
27.	Лідерство - навчання проектних команд для отримання оптимальних результатів
28.	Управління змінами - забезпечення ефективного управління змінами
29.	Успішне ведення переговорів - вирішення конфліктів і ведення переговорів
30.	Планування кар'єрного зростання - структуризація і управління ходом реалізації кар'єри
31.	Ефективне уявлення - використання письмових і усних навиків
32.	Набір персоналу - вербування і співбесіда з членами команди
33.	Відбір команди - висококомпетентних фахівців
34.	Створення команди - формування, керівництво і підтримка ефективної команди

# Билет 38. Методологическая основа Объектно-ориентированного анализа.

Концептуальною основою объєктно-орієнтованого аналізу і проектування ПО (ООАП) є об’ектна модель. ЇЇ основні прінципи – абстрагування, інкапсуляція, модульність і іерархія,  поняття – об’єкт, клас, атрібут, операція, інтерфейс.

Більшість сучасних методів ООАП  засновані на використанні мови UML. Уніфікованою мовою моделювання UML (Unified Modeling Language) є мова для визначення, уявлення, проектування і документування програмних систем, організаційно-економічних систем, технічних систем і інших систем різної природи. UML містить стандартний набір діаграм і нотацій найрізноманітніших видів.

**Об'єктно-орієнтований аналіз** - це перший крок на шляху об'єктно-орієнтованого проектування.

**Об'єктно-орієнтоване проектування** - це об'єктно-орієнтований аналіз, на основі якого ми формуємо об'єктно-орієнтований опис об'єктної області. 
Сформувавши об'єктно-орієнтований опис ми формуємо об'єктно-орієнтоване проектування.

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-22%20at%2000.54.54.png?_subject_uid=76410387&w=AAA6AzS8wU09nfyy55S_yAcUcBR07oOqDwj9LJ-bdFcmVw)

**Вихідні дані для аналізу:**

Приступаючи до розв'язання задачі об'єктно-орієнтованого аналізу, системний аналітик повинен виділити в вихідній предметній області декілька чітко визначених областей або доменів. Приступаючи до роботи, аналітик бачить:

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-22%20at%2000.54.50.png?_subject_uid=76410387&w=AACOh8aqWen7ajfDh5L8HVUBE_YPKnnd-BB8LGcIT_sLJg)

Ми визначили зв'язки між підзадачами Кожен домен повинен розглядатися як самостійний інформаційний простір населений власними концептуальними сутностями або об'єктами. Тому в автоматизованій системі управління залізницею домен "роботи залізниці" населений такими концептуальними сутностями' вагон, поїзда, стрілочники Кожен домен може існувати більш чи менш незалежно від інших (наприклад, поїзда, вагони можуть існувати бедз вікон) Деякі домени малі, тобто кількість об'єктів в них невелика, і вони можуть розглядатись як єдине ціле Крупні домени (велика кількість об'єктів) розбиваються на підсистеми.

Для кожної підсистеми створюється 3 моделі

- інформаційна модель
- модель станів
- модель процесів

Після того, як система розбита на домени і підсистеми, починається аналіз Кожна система або підсистема аналізується незалежно одна від іншої в три етапи: 

1. Інформаційне моделювання
2. Моделювання станів
3. Моделювання процесів

CASE - програмні системи для автоматизації програмування
Інформаційні моделі

Мета етапу інформаційного моделювання полягає в тому, щоб ідентифікувати концептуальні сутності або об' єкти, які складають підсистеми аналізу.

Беремо підсистему руху поїздів:

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-22%20at%2000.54.44.png?_subject_uid=76410387&w=AABc-7hMUrVTk5lzGTOcyeMy9CSol38S6ymePxLl_so1Tg)

**Моделі станів**

Модель станів	описує поведінку об'єктів в створених інформаційних моделях в часі.

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-22%20at%2000.54.40.png?_subject_uid=76410387&w=AADInv3jY7GaOmHwbUKHSmpZDVEDH5rTsVSaxapOEnbc-Q)

Кожен об'єкт і зв'язок між об'єктами можуть мати життєвий цикл або організовану систему поведінки (об'єкт поїзд рухається по залізниці, під'їжджаючи до станції, сповільнює рух, зупиняється, відкриває двері вагона і т.д., коли він готовий до відправлення, то подає сигнали). Тобто є ряд ситуацій, через які повинен пройти кожен об' єкт

Життєвий цикл об єкта формалізується у вигляді множини станів і подій.
Стани являють собою положення або ситуацію об'єкта, в яких використовуються певні фізичні закони, правила і лінії поведінки.

Події являють собою інцидент, який примушує об' єкт переходити з одного стану в інший. Моделі станів формуються для кожного об'єкта і зв'язку, які мають інтересуючу нас динамічну поведінку. З кожним станом пов'язана деяка діяльність. Ця діяльність, яку називають дією, відбувається в той час, коли об'єкт досягає стану.

Для того, щоб досягти согласованої поведінки різних об'єктів, моделі станів взаємодіють між собою за допомогою подій.

**Наприклад.**

модель стану поїзда	може породжувати подію для об'єктів, з яких 
складається вагон: П81,П82 - відкривання та зачинення дверей.

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-22%20at%2000.54.35.png?_subject_uid=76410387&w=AAChFkdJwvrM6eQH9JawmEKlfAy65_Xu4CEaBYvbjM8Aqw)

Події, які описують поведінку кожного об' єкта, приймають участь і в синхронізації поведінки об' єктів

В моделі взаємодії об'єктів створюються взаємодії між підсистемами і деякі події, що беруть участь в синхронізації взаємодії між підсистемами

**Моделі процесів**

Сформувавши моделі станів кожного об'єкта, для кожної дії, визначеної в різних станах дається його повний функціональний опис. Цей опис має такий вигляд.

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-22%20at%2000.54.29.png?_subject_uid=76410387&w=AABNA42gG5GezcYe5kR84F-0yyqtTkfi5S8KGxF7aD2Pdw)

Для кожної дії, визначеної в моделі станів, визначається звідки беруться дані для реалізації даної дії. Тобто в результаті об'єктно-орієнтованого аналізу ми формуємо такий документ

1. Опис і обгрунтування виділеного домена для досліджуваної предметної області 
2.  Опис і обгрунтування виділених підсистем для складних доменів
3.  Інформаційні моделі для кожної підсистеми і нескладного домена
4. Опис об' єктів та їх атрибутів для кожної інформаційної моделі, включаючи опис зв'язків кожного об'єкту
5. Моделі станів для кожного об'єкта
6. Модель взаємодії об'єктів
7. Модель взаємодії підсистем
8. Моделі процесів для кожної дії в моделі станів об' єктів

# Билет 39. Объекты и атрибуты объектов информационной модели предметной области.

## Поняття об'єкта

В об'єктно-орієнтованому аналізі об'єкт - це така абстракція множини предметів реального світу, в якій:

1. Всі предмети в цій множині або екземпляр мають одні й ті ж характеристики..
2. Всі екземпляри підкорені і узгоджуються з одним й тим самим набором правил поведінки

Кожен об'єкт в моделі повинен бути забезпечений унікальним і значимим ім'ям, а також унікальним ключовим ітералом ( короткою формою ім'я ). У великій моделі для організації документації об'єкти, крім того, повинні бути пронумеровані Спеціального терміна для визначення сукупності екземплярів деякого об'єкта в об' єктно- орієнтованому програмуванні не існує.

Об'єкти ідентифікуються шляхом розглядання концептуальної сутності, пов'язаної з аналізированим управлінням. Ряд задач припускають створення об'єктів, що мають фізичний характер. Інші задачі породжують породжують абстрактні об'єкти.

Якщо класифікувати, то більшість об'єктів створених в об'єктно-орієнтованому аналізі відносяться до таких категорій:

1. Реальні об' єкти
2. Ролі
3. Інциденти
4. Взаємодія
5. Специфікація

**Реальні об'єкти** - це абстракції фактичного існування деяких об'єктів у фізичному світі.
**Ролі** - це абстракції мети або призначення людини, частини обладнання, організації
**Інциденти** - це абстракція чогось, що зчинилося або сталося
**Об'єкти взаємодії** - це об'єкти, що одержуються із співвідношень між іншими об' єктами
**Специфікації** - використовуються для представлення правил, стандарту або критерію 
якості

## Опис об'єктів

**Опис** - це коротке інформативне твердження, яке дозволяє встановити чи є реальний предмет екземпляром або ні.

Опис об'єкта повинен бути основан на абстракції, яка точно пояснює подібність предметів реального світу. Наприклад, є об'єкт, що знімає показання приладу, - це штатний службовець (електрик), який може прочитати значення, що відображаються на електричних приладах і в цей час виконує це завдання.

## Атрибути об'єкта

**Атрибут** - це абстракція однієї характеристики, яку мають всі абстраговані як об'єкт сутності. Кожен атрибут забезпечується іменем унікальним в межах об'єкту.

Щоб звернутися до атрибута пишуть: `<ім'я об'єкта>.<ім'я атрибута>`

**Наприклад:**

	<літак>. <тип>
	<студент>.<прізвище>

Атрибутів у об'єкта може бути декілька. Для будь-якого екземпляра об'єкту атрибут приймає значення. Для атрибута може визначатись діапазон можливих значень.

**Ідентифікатор об'єкта** - це множина з одного чи більш атрибутів, значення яких однозначно визначає кожен екземпляр об'єкта.

Об'єкт може мати декілька ідентифікаторів При цьому кожен ідентифікатор може бути побудован з одного чи декількох атрибутів. Якщо об'єкт має декілька ідентифікаторів, то один з них вибирається привілейованим.

При розробленні моделей об'єктно- орієнтованого аналізу об'єкт зображується графічно у вигляді прямокутника, що містить ім'я, номер і ключовий ітерал об'єкта, а також імена атрибутів. Атрибути, що складають привілейований ідентифікатор об'єкта відмічаються * або ніяк. А решта відмічаються • зліва. Можливо текстове представлення об'єкта.  Привілейований  ідентифікатор  в  текстовому  представленні  об'єктів підкреслюється.

Літак (ID літака, розмах крила)

**Типи атрибутів**

1. Описові
2. Вказуючі
3. Допоміжні

Описові атрибути представляють факти, внутрішньо притаманні кожному екземпляру об'єктів. Якщо значення описового атрибута змінюється, то це говорить-про те, що деякий аспект екземпляра змінився, але сам екземпляр залишився старим.

Вказуючі атрибути використовуються для ідентифікації екземплярів. Вказуючі атрибути використовуються, як ідентифікатори, але бувають випадки. Допоміжні атрибути використовуються для зв'язку екземпляра одного об'єкта з екземпляром іншого.

**Опис атрибутів**

Опис атрибутів залежить від типа атрибута. Для описових атрибутів опис повинен встановлювати реальну характеристику, яка абстрагується, як атрибут.

Опис діапазону значень надається одним з декількох способів:

1. Переліченням всіх можливих значень, які атрибут може приймати.
2. Посиланням на документ, що приводить можливі значення
3. Формулюванням правила, яке визначає які значення допустимі 

Для вказуючих атрибутів опис встановлює форму указання, організацію, яка призначає указання та степінь, в якій ім'я атрибута може використовуватись, як частина ідентифікатора Для допоміжних атрибутів опис повинен вказувати реальне відношення, що встановлюється атрибутами.

**Правила атрибутів**

Інформаційна модель грунтується на реалідійному представленні даних, тобто представленні даних у вигляді відношень між ними. Тому вводяться наступні правила для атрибутів об'єктів інформаційних технологій:

1. Забороняється створення об' єктів, в яких маються атрибути, що повторюються
2. Атрибут не повинен мати ніякої внутрішньої структури, тобто його неможна розкласти на атрибути більш низького рівня
3. Кожен атрибут, що не е частиною ідентифікатора характеризує весь об' єкт, а не його частиною
4. Кожен атрибут, що не є частиною ідентифікатора характеризує екземпляр об' єкта, який вказаний ідентифікатором, а не визначає інші атрибути ідентифікатора

# Билет 40.Связи объектов в информационной модели, типы и описания связей.

## Зв'язки між об'єктами

Зв'язок - це абстракція відношень, які виникають між різними предметами в реальному світі
Реальні предмети, що беруть участь у відношенні, повинні бути абстрагованими, як об'єкти Кожен зв'язок в моделі задається парою імен, які описують цей зв'язок із перспективи кожного об'єкта, який бере участь в зв'язку. Наприклад, поїзд включає вагони, вагони належать поїзду.
Існують три функціональні види зв'язку:
1 Один до одного
2. Один до багатьох
З Багато до багатьох
Ці функціональні види зв'язку називаються безумовними формами
Зв'язок один до одного існує коли один екземпляр одного об'єкта пов'язан з єдиним екземпляром іншого
Зв'язок один до багатьох існує коли один екземпляр деякого об'єкта пов'язан з одним чи більш екземплярами іншого, і кожен екземпляр другого об'єкта пов'язан тільки з одним екземпляром першого
Зв'язок багато до багатьох існує коли один екземпляр деякого об'єкта пов'язан з одним чи більшою кількістю екземплярів іншого, і кожен екземпляр другого об'єкта пов'язан з одним чи більш екземплярами першого
Графічно це виглядає так

![image](https://dl.dropboxusercontent.com/u/8382381/images/40_1.png)


## Умовні зв'язки

Основний зв'язок визначає, що можуть існувати такі об'єкти, які не зв'язані Ці моделі помічаються літерою Y після відповідної стрілки зв'язку:

![image](https://dl.dropboxusercontent.com/u/8382381/images/40_2.png)

## Опис зв'язків
Опис кожного зв'язка включає:


* ідентифікатор зв'язку;
* ид зв'язку;
* формулювання того, як зв'язок був реалізован;

Можливе формулювання імені зв'язку з точки зору кожного об'єкта що бере участь.
Деякі зв'язки утворюються, як наслідки існування інших зв'язків. Наприклад:

![image](https://dl.dropboxusercontent.com/u/8382381/images/40_3.png)

Відношення існують між викладачем і студентом, але це викликає відношення між студентом і факультетом.

## Підтипи і супертипи

Поняття підтипа і супертипа аналогічно до поняття ієрархії. Підтип - це об' єкт, що має спільні атрибути з об' єктом супер типа. Атрибути, спільні для всіх об'єктів підтипу, знаходяться в об'єкті супертипа Об'єкти підтипу можуть мати свої додаткові атрибути.

![image](https://dl.dropboxusercontent.com/u/8382381/images/40_4.png)

## Аналіз зв'язків між об'єктами


Відношення між об'єктами (предметами) в реальному світі розвиваються в часі Відношення між об'єктами формалізуються у вигляді зв'язків. Формалізація відношення в інформаційній моделі представляє собою її статичні описи, які не відображають факта існування цього зв'язку в часі, тобто зв'язок як таковий між об'єктами може бути динамічним. Інформаційна модель не відображає того, які екземпляри об'єктів беруть участь в зв'язку
Так як зв'язок може бути динамічним, виникає поняття життєвого циклу зв'язку Життєвий цикл зв'язку або модель станів зв'язку описує поведінку типового невизначеного екземпляра зв'язку. Якщо зв'язок не має житєвого цикла, то він може обладати динамічною поведінкою за умови, що екземпляри зв'язку створюються і знищуються в межах повного життєвого циклу програмної системи, що аналізується

## Конкуруючі зв'язки

Вони виникають в тих випадках, коли декілька об'єктів претендують на встановлення зв'язків один з одним в один й той же момент часу
Проблеми конкуренції такого типу вирішуються за допомогою перетворення конкуруючих запитів в послідовний ланцюг запитів. В об'єктно-орієнтованому аналізі розробляться спеціальна модель станів зв'язків, яка враховує різні стратегії упорядкування конкуруючих запитів.
Основою моделі станів є так званий визначник стану зв'язку Визначник стану зв'язку аналізується монітором або керуючим обладнанням моделі станів Принцип упорядкування такий: кожен запит постачається атрибутом статусу. Отже відповідно до цього будується черга.

# Билет 41. Жизненные циклы объектов – модели поведения в реальном мире.

**Життєві цикли об'єкта**

Закінчивши розробку інформаційної моделі, ми отримали її структуру, опис об'єктів і атрибутів, і опис зв'язків. Після закінчення розробки інформаційної моделі розробляються життєві цикли об'єктів. Будь-які об'єкти реального світу динамічні в часі (мають динамічну поведінку моделі). Можна казати, що кожен об'єкт має свій строк життя. Можуть бути запропоновані наступні параметри опису поведінки різних предметів:

1. Об' єкти реального світу на протязі їх строка життя проходять різні стадії
2. Порядок еволюціонування об'єкта формує характерний відмітний признак поведінки цього об' єкта. Тобто будь-який об' єкт має свій порядок поведінки
З. В будь-який сучасний момент часу реальний об'єкт знаходиться в одній єдиній стадії
4. Об'єкти еволюціонують від однієї стадії до іншої стрибкоподібне. Це залежить від рівня абстрагування процесу поведінки літака
5. В схемі поведінки об'єкта дозволені не всі еволюції між стадіями (деякі еволюції забороняються законами фізики)
6. Об'єкти еволюціонують в наслідок інциденту, тобто перехід від стадії до стадії діється в результаті інциденту, тобто інцидент є деяка подія.

Так як всі екземпляри об'єктів підкоряються одним й тим самим правилам поведінки, то, абстрагуючи об'єкт, ми абстрагуємо і спільну модель поведінки всіх його екземплярів.
Життєвим циклом об'єкта називається формалізований опис моделі поведінки об' єкта, що спільно використовується всіма екземплярами.

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-22%20at%2001.12.20.png?_subject_uid=76410387&w=AAC1UPe5fAYAe_0C5D6wQKe1tIIUq3DRbNuk_RETmzM3xA)

Життєвий цикл об' єкта - модель стану об' єкта. Життєві цикли можуть описуватись як:

- діаграма станів
- у вигляді таблиці кінцевого автомата

**Модель станів для об'єкта рахунка**

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-22%20at%2001.12.26.png?_subject_uid=76410387&w=AAA6WLOy188FRUyVMOIqPzyCIFlHqqXc3YrKXLWzBY-Z3w)

**Координація життєвих циклів**
Життєві цикли різних об' єктів координуються один з одним.

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-22%20at%2001.12.31.png?_subject_uid=76410387&w=AAD9dJYaDc4iKN34ZdU2UgSL5IromV215yWgD1kvbk6Lig)

Кожен з цих об'єктів має свій життєвий цикл.

Множина станів, в яких може знаходитись кожен об' єкт, - це множина значень, що приймає статус ( його атрибутів). Поточний стан атрибута статус є поточний стан об'єкта. Стан - положення об'єкта, в якому виконується певний набір правил приписів або
фізичних законів.
Кожному стану присвоюється унікальний номер. В моделі станів виділяються
стани, в яких екземпляр об'єкта з'являється вперше і активізується. Такі стани називаються станами створення.
Перехід в стан створення позначається стрілкою, яка зв'язує якісь елементи станів:

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-22%20at%2001.12.36.png?_subject_uid=76410387&w=AAB_z6JBA5-Chc6NLRRbQt-N8hr21yBUzcTPKIAKwZgQow)

Крім того, в моделі станів виділяються так звані заключні стани - стани, в яких екземпляр об'єкта припиняє своє існування (існувань в життєвому циклі може бути одне чи декілька).

Заключність стана може представляти одну з таких ситуацій:

1. Екземпляр стає нерухомим (тобто він залишається в межах моделі, але не активен)
2. Екземпляр вилучається з програмної моделі

**Поточний стан**

В будь-який момент часу екземпляри об' єктів можуть знаходитись в різних станах Ідентифікація поточного стану здійснюється через атрибут об'єкта, який називається статусом.

**Подія**

Подія - це абстракція інциденту або деякого сигналу в реальному світі, який інформує про переміщення екземпляра об'єкта в новий стан. Абстрактна подія має чотири інтерпритаціі

- значення
- призначення
- мітка
- дані (тобто подія може нести якісь дані)

Значення міститься в короткій фразі, яка повідомляє, що діється в реальному світі
Призначення несе інформацію про моделі станів, яка ініціалізується або приймає дані подіє Використовується для того, щоб синхронізувати життєві цикли різних об'єктів (зв'язати один з одним).

Мітки спеціального призначення не мають Служать для ідентифікації самої події і сполучаються або значенням або призначенням. 

Дані служать для передачи повідомлення разом із самою подією і сполучаються зі значеннями або призначеннями.

Мітки подій повинні визначатися так, щоб всі події, які приймаються даним об' єктом, починалось з одного й того ж ітерала
Дані подій

В програмній моделі події можна інтерпретувати, як сигнал повідомлень, який можна переносити Дані бувають:

1. Ідентифікуючі
2. Додаткові

**Ідентифікуючі** - атрибути, що визначають якісь параметри об' єкта.
**Додаткові** - дані, які треба перенести з одного стану в інший або передавати в якийсь поточний стан об' екта.

Існує ряд правил, які зв'язують дані, що передаються з подіями, з поточними станами 
об' єкта:

1. Правило тих самих даних. Всі події, що визивають перехід в певний стан, повинні нести одні й тіж типи даних Гарантує, що яка б подія не перевела об'єкт в стан, функціонувати він буде правильно.
2. Правило стану не створень. Якщо подія викликає перехід стану, який не є станом створення об'єкту, то ідентифікатор екземпляра, до якого події використовуються, може бути відсутньою, але якщо програмні моделі активні декілька екземплярів одного й того ж об' єкта, то передача ідентифікатора екземпляра обов'язкова
3. Правило стану створень. Якщо подія викликає перехід стану створення нового екземпляра об'єкту, воно може не нести ідентифікатор екземпляра тільки в тому випадку, якщо цей ідентифікатор генерується в стан створення. 

Один інцидент в реальному світі може бути абстрагрован в більш ніж одну подію Модель станів мікрохвильової печі.

# Билет 42.Понятие действия в жизненном цикле объекта.

## Дія
**Дія** - це діяльність або операція, яка повинна бути виконана екземпляром об'єкта при досягнені ним поточного стану.
З кожним станом обов'язково повинна бути пов'язана одна дія Використовуючи одну й ту саму модель станів, дії повинні бути визначені так, щоб вони могли бути виконані будь-яким екземпляром

Дії дозволяють виконати такі операції:


* Виконати будь-які обчислення
* Породжувати події для будь-якого екземпляра об'єкта
* Породжувати події для будь-якої зовнішньої системи або підсистеми, включаючи аппаратну частину
* Створювати, вилучати, встановлювати або обнуляти таймер
* Читати і записувати атрибути інших екземплярів власного об'єкта
* Читати і записувати атрибути інших екземплярів інших об' єктів


Щоб гарантувати не суперечність моделі станів, на дії накладаються обмеження
- будь-яка дія може гарантувати не суперечність даних власного екземпляра об'єкта, тобто якщо модифікуються атрибути власного екземпляра, то атрибути всіх екземплярів, що залежать від нього, повинні бути перелічені
- якщо дія створює або вилучає екземпляр об'єкта, то вона може гарантувати, що будь-які зв'язки, включаючи ці екземпляри, або вилучаються або перебудовуються (перепризначуються)
- дія може гарантувати не суперечність екземплярів підтипів і супертипів (якщо виличається підтип, то можна перевірити можливі вилучення супертипа)
Опис дій
В процесі об'єктно-орієнтованого аналізу описуються в текстовій формі або на деякому псевдокоді, який вибирається розробником.
В процесі виконання об'єктно-орієнтованого аналізу треба зв'язати дії, події і час Для цього виконуються певні припущення про час

* Тільки одна дія в моделі станів може виконуватись в конкретний час Якщо дія почата - вона повинна закінчитися раніше ніж обробиться нова подія.
* Дії в різних моделях станів можуть виконуватись одночасно.
* Події ніколи не губляться.
* Якщо подія породжена для екземпляра, який виконує дії, то подія не буде прийнята до завершення дії
* Після обробки події зникають

Якщо по одній і тій ж події переходимо в різні стани, то отримаємо диаграму

![image](https://dl.dropboxusercontent.com/u/8382381/images/42_1.png)

## Таймери
Таймер - це механізм, який використовується дією для створення події через певний наперед заданий час Атрибутами таймера є:


1. Ідентифікатор таймера
2. Час до моменту формування події
3. Мітка події
4. Ідентифікатор екземпляра таймера.

![image](https://dl.dropboxusercontent.com/u/8382381/images/42_2.png)


# Билет 44. Предметы словаря UML
UML – стандартный язык для написания моделей анализа, проектирования и реализации объектно-ориентированных программных систем. UML может использоваться для визуализации, спецификации, конструирования и документирования результатов программных проектов. UML – это не визуальный язык программирования, однако его модели прямо транслируются в текст на языках программирования (Java, C++, Visual Basic, Object Pascal) и даже в таблицы для реляционной БД.

Словарь UML образуют три разновидности строительных блоков:
предметы, отношения, диаграммы.

**Предметы** – это абстракции, которые являются основными элемен-
тами в модели, отношения связывают эти предметы, диаграммы группи-
руют коллекции предметов.

## ПРЕДМЕТЫ В UML

В UML имеются четыре разновидности предметов:
- структурные предметы;
- предметы поведения;
- группирующие предметы;
- поясняющие предметы.

Эти предметы являются базовыми объектно-ориентированными строительными блоками. Они используются для написания моделей. Структурные предметы являются существительными в UML-моделях. Они представляют статические части модели – понятийные или физические элементы. Перечислим восемь разновидностей структурных предметов.

1. Класс – описание множества объектов, которые разделяют одинаковые свойства, операции, отношения и семантику (смысл). Класс реализует один или несколько интерфейсов. Как показано на рис. 3.1, графически класс отображается в виде прямоугольника, обычно включающего секции с именем, свойствами (атрибутами) и операциями.
2. Интерфейс – набор операций, которые определяют услуги класса или компонента. Интерфейс описывает поведение элемента, видимое извне. Интерфейс может представлять полные услуги класса или компонента или часть таких услуг. Интерфейс определяет набор спецификаций операций (их сигнатуры), а не набор реализаций операций. Графически интерфейс изображается в виде кружка с именем, как показано на рис. 3.2. Имя интерфейса обычно начинается с буквы «I». Интерфейс редко показывают самостоятельно. Обычно его
присоединяют к классу или компоненту, который реализует интерфейс.
3. Кооперация (сотрудничество) определяет взаимодействие и является совокупностью ролей и других элементов, которые работают вместе
для обеспечения коллективного поведения более сложного, чем простая
сумма всех элементов. Таким образом, кооперации имеют как структурное, так и поведенческое измерения. Конкретный класс может участвовать в нескольких кооперациях. Эти кооперации представляют реализацию паттернов (образцов), которые формируют систему. Как показано на рис. 3.3, графически кооперация изображается как пунктирный эллипс, в который вписывается её имя.
4. Актёр – набор согласованных ролей, которые могут играть пользователи при взаимодействии с системой (её элементами Use Case). Каждая роль требует от системы определённого поведения. Как показано на рис. 3.4, актёр изображается как проволочный человечек с именем.
5. Элемент Use Case (Прецедент) – описание последовательности действий (или нескольких последовательностей), выполняемых системой в интересах отдельного актёра и производящих видимый для актёра результат. В модели элемент Use Case применяется для структурирования предметов поведения. Элемент Use Case реализуется кооперациеКак показано на рис. 3.5, элемент Use Case изображается как эллипс, в Рис. 3.6. Активные классы который вписывается его имя.
6. Активный класс – класс, чьи объекты имеют один или несколько процессов (или потоков) и поэтому могут инициировать управляющ. щую деятельность. Активный класс похож на обычный класс за исключением того, что его объекты действуют одновременно с объектами других классов. Как показано на рис. 3.6, активный класс изображается как утолщённый прямоугольник, обычно включающий имя, свойства (атрибуты) и
операции.
7. Компонент – физическая и заменяемая часть системы, которая соответствует набору интерфейсов и обеспечивает реализацию этого набора интерфейсов. В систему включаются как компоненты, являющиеся результатами процесса разработки (файлы исходного кода), так и различные разновидности используемых компонентов (СОМ+-компоненты, Java Beans). Обычно, компонент – это физическая упаковка различных логических элементов (классов,
интерфейсов и сотрудничеств). 

8. Узел – физический элемент, который су- Рис. 3.7. Компоненты
ществует в период работы системы и представляет ресурс, обычно имеющий память и возможности обработки. В узле размещается набор компонентов, который может перемещаться от узла к узлу. 

**Предметы поведения** – динамические части UML-моделей. Они являются глаголами моделей, представлением поведения во времени и пространстве. Существует две основные разновидности предметов поведения.

1. Взаимодействие – поведение, заключающее в себе набор сообщений, которыми обменивается набор объектов в конкретном контексте для достижения определённой цели. Взаимодействие может определять динамику как совокупности объектов, так и отдельной операции. Элементами взаимодействия являются сообщения, последовательность действий (поведение, вызываемое сообщением) и связи (соединения между объектами). Как показано на рис. 3.9, сообщение изображается в
виде направленной линии с именем её операции.
 2. Конечный автомат – поведение, которое
определяет последовательность состояний объекта
или взаимодействия, выполняемые в ходе его существования в ответ на события (и с учётом обязанностей по этим событиям). С помощью конечного автомата может определяться поведение индивидуального класса или кооперации классов. Элементами конечного автомата являются состояния,
переходы (от состояния к состоянию), события (предметы, вызывающие
переходы) и действия (реакции на переход). Как показано на рис. 3.10,
состояние изображается как закруглённый прямоугольник, обычно вклю-
чающий его имя и его подсостояния (если они есть).

Эти два элемента – взаимодействия и конечные автоматы – являются
базисными предметами поведения, которые могут включаться в UML-модели. Семантически эти элементы ассоциируются с различными структурными элементами (прежде всего с классами, сотрудничествами и объектами).

**Группирующие предметы** – организационные части UML-моделей.
Это ящики, по которым может быть разложена модель. Предусмотрена
одна разновидность группирующего предмета – пакет.

**Пакет** – общий механизм для распределения элементов по группам. В пакет могут помещаться структурные предметы, предметы поведения и даже другие группировки предметов. В отличие от компонента (который существует в период выполнения), пакет – чисто концептуальное понятие. Это означает, что пакет существует только в период разработки. Как показано на рис. 3.11, пакет изображается как папка с закладкой, на которой обозначено его имя и, иногда, его содержание.

**Поясняющие предметы** – разъясняющие части UML-моделей. Они
являются замечаниями, которые можно применить для описания, объяснения и комментирования любого элемента модели. Предусмотрена одна разновидность поясняющего предмета – примечание.

*Примечание – символ для отображения ограничений и замечаний, присоединяемых к элементу или совокупности элементов. Как показано на
рис. 3.12, примечание изображается в виде прямоугольника с загнутым углом, в который вписывается текстовый или графический комментарий.*

# Билет 45. Отношения словаря UML

В UML имеются четыре разновидности отношений:

1. зависимость;
2. ассоциация;
3. обобщение;
4. реализация.

Эти отношения являются базовыми строительными блоками отношений. Они используются при написании моделей.

1. **Зависимость** – семантическое отношение между двумя предметами, в котором изменение в Рис. 3.13. Зависимости одном предмете (независимом предмете) может влиять на семантику другого предмета (зависимого предмета). Как показано на рис. 3.13, зависимость изображается в виде пунктирной линии,
возможно направленной на независимый предмет и иногда имеющей метку.
2. **Ассоциация** – структурное отношение, которое описывает набор связей, являющихся соединением между объектами.
Агрегация – это специальная разновидность ассоциации, представляющая структурное отношение между целым и его частями. Как показано на рис. 3.14,
ассоциация изображается в виде сплошной линии, возможно направленной, иногда имеющей метку и часто включающей другие «украшения»,
такие как мощность и имена ролей.
3. **Обобщение** – отношение специализации/обобщения, в котором объекты специализированного элемента (потомка, ребенка) могут заменять объекты обобщённого элемента (предка, родителя). Иначе говоря, потомок разделяет структуру и поведение родителя. Как показано на рис. 3.15, обобщение изображается в виде сплошной стрелки с полым наконечником, указывающим на родителя.
4. **Реализация** – семантическое отношение между классификаторами, где один классификатор определяет контракт, который другой классификатор обязуется выполнять (к классификаторам относят классы, интерфейсы, компоненты, элементы Use Case, кооперации). Отношения реализации применяют в двух случаях: между интерфейсами и классами (или компонентами), реализующими их; между элементами Use Case и кооперациями, которые реализуют их. Как показано на рис. 3.16, реализация изображается как нечто среднее между обобщением и зависимостью.

# Билет 46. Диаграммы словаря UML. Расширения семантики UML

**Диаграмма** – графическое представление множества элементов, наи-
более часто изображается как связный граф из вершин (предметов) и дуг
(отношений). Диаграммы рисуются для визуализации системы с разных
точек зрения, затем они отображаются в систему. Обычно диаграмма даёт
неполное представление элементов, которые составляют систему. Хотя
один и тот же элемент может появляться во всех диаграммах, на практике
он появляется только в некоторых диаграммах. Теоретически диаграмма
может содержать любую комбинацию предметов и отношений, на прак-
тике ограничиваются малым количеством комбинаций, которые соответ-
ствуют пяти представлениям архитектуры ПС. По этой причине UML
включает девять видов диаграмм:

1. диаграммы классов;
2. диаграммы объектов;
3. диаграммы Use Case (диаграммы прецедентов);
4. диаграммы последовательности;
5. диаграммы сотрудничества (кооперации);
6. диаграммы схем состояний;
7. диаграммы деятельности;
8. компонентные диаграммы;
9. диаграммы размещения (развёртывания).

**Диаграмма классов** показывает набор классов, интерфейсов, сотруд-
ничеств и их отношений. При моделировании объектно-ориентированных
систем диаграммы классов используются наиболее часто. Диаграммы
классов обеспечивают статическое проектное представление системы.

**Диаграммы классов**, включающие активные классы, обеспечивают стати-
ческое представление процессов системы.

**Диаграмма объектов** показывает набор объектов и их отношения.

Диаграмма объектов представляет статический «моментальный снимок» с
экземпляров предметов, которые находятся в диаграммах классов. Как и
диаграммы классов, эти диаграммы обеспечивают статическое проектное
представление или статическое представление процессов системы (но с
точки зрения реальных или фототипичных случаев).

**Диаграмма Use Case** (диаграмма прецедентов) показывает набор
элементов Use Case, актёров и их отношений. С помощью диаграмм Use
Case для системы создаётся статическое представление Use Case. Эти диаграммы особенно важны при организации и моделировании поведения системы, задании требований заказчика к системе.

**Диаграммы последовательности** и **диаграммы сотрудничества** – это
разновидности диаграмм взаимодействия.

**Диаграмма взаимодействия** показывает взаимодействие, включающее набор объектов и их отношений, а также пересылаемые между объек
тами сообщения. Диаграммы взаимодействия обеспечивают динамиче
ское представление системы.

**Диаграмма последовательности** – это диаграмма взаимодействия,
которая выделяет упорядочение сообщений по времени.

**Диаграмма сотрудничества** (диаграмма кооперации) – это диаграмма взаимодействия, которая выделяет структурную организацию объектов, посылающих и принимающих сообщения. Диаграммы последовательности и диаграммы сотрудничества изоморфны, что означает, что одну диаграмму можно трансформировать в другую диаграмму.

**Диаграмма схем** состояний показывает конечный автомат, представляет состояния, переходы, события и действия. Диаграммы схем состояний обеспечивают динамическое представление системы. Они особенно важны при моделировании поведения интерфейса, класса или сотрудничества. Эти диаграммы выделяют такое поведение объекта, которое
управляется событиями, что особенно полезно при моделировании реактивных систем.

**Диаграмма деятельности** – специальная разновидность диаграммы
схем состояний, которая показывает поток от действия к действию внутри
системы. Диаграммы деятельности обеспечивают динамическое представление системы. Они особенно важны при моделировании функциональности системы и выделяют поток управления между объектами.

**Компонентная диаграмма** показывает организацию набора компонентов и зависимости между компонентами. Компонентные диаграммы
обеспечивают статическое представление реализации системы. Они связаны с диаграммами классов в том смысле, что в компонент обычно отображается один или несколько классов, интерфейсов или коопераций.

**Диаграмма размещения** (диаграмма развёртывания) показывает конфигурацию обрабатывающих узлов периода выполнения, а также компоненты, живущие в них. Диаграммы размещения обеспечивают статическое представление размещения системы. Они связаны с компонентными диаграммами в том смысле, что узел обычно включает один или несколько компонентов.

## МЕХАНИЗМЫ РАСШИРЕНИЯ В UML

**UML** – развитый язык, имеющий большие возможности, но даже он
не может отразить все нюансы, которые могут возникнуть при создании
различных моделей. Поэтому UML создавался как открытый язык, допус-
кающий контролируемые расширения. Механизмами расширения в UML
являются:

- ограничения;
- теговые величины;
- стереотипы.

**Ограничение** (*constraint*) расширяет семантику строительного UML-блока, позволяя добавить новые правила или модифицировать существующие. Ограничение показывают как текстовую строку, заключённую в фигурные скобки `{}`. 

**Теговая величина** (*tagged value*) расширяет характеристики строительного UML-блока, позволяя создать новую информацию в спецификации конкретного элемента. Теговую величину показывают как строку в фигурных скобках `{}`. Строка имеет вид
`имя теговой величины = значение`.

Иногда (в случае предопределённых тегов) указывается только имя
теговой величины. Отметим, что при работе с продуктом, имеющим много реализаций,
полезно отслеживать версию и автора определённых блоков. Версия и
автор не принадлежат к основным понятиям UML. Они могут быть добавлены к любому строительному блоку (например, к классу) введением в блок новых теговых величин.

**Стереотип** (*stereotype*) расширяет словарь языка, позволяет создавать новые виды строительных блоков, производные от существующих и учитывающие специфику новой проблемы. Элемент со стереотипом является вариацией существующего элемента, имеющей такую же форму, но отличающуюся по сути. У него могут быть дополнительные ограничения
и теговые величины, а также другое визуальное представление. Он иначе обрабатывается при генерации программного кода. Отображают стереотип как имя, указываемое в двойных угловых скобках (или в угловых кавычках).

Таким образом, механизмы расширения позволяют адаптировать UML под нужды конкретных проектов и под новые программные технологии. Возможно добавление новых строительных блоков, модификация спецификаций существующих блоков и даже изменение их семантики.
Конечно, очень важно обеспечить контролируемое введение расширений.

# Билет 49. Диаграмма классов UML. Понятие множественности			
Множественность (multiplicity) показывает, сколько экземпляров одного класса взаимодействуют с помощью этой связи с одним экземпляром другого класса в данный момент времени.
					
Например, при разработке системы регистрации курсов вуниверситете можно определить классы Course (курс) и Student (студент). Между ними установлена связь: у курсов могут быть студенты, а у студентов – курсы. Вопросы, на который должен ответить параметр множественности: «Сколько курсов студент может посещать в данный момент? Сколько студентов может за раз посещать один курс?»
					
Так как множественность дает ответ на оба эти вопроса, её индикаторы устанавливаются на обоих концах линии связи. В примере регистрации курсов мы решили, что один студент может посещать от нуля до четырех курсов, а один курс могут слушать от 10 до 20 студентов. На диаграмме классов это можно изобразить, как показано на рис. 				
![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-21%20at%2022.22.50.png?_subject_uid=76410387&w=AAAi8MBimvp5r13JmScw6kyvcPwZH1FJWG045Z7mO4Vcfw)

В языке UML приняты следующие нотации для обозначения множественности: 

| Множественность | Значение |
|-|-|
| 0..* | Ноль или больше |
| 1..* | Один или больше |
| 0..1 | Ноль или один |
| 1..1 (сокращенно: 1) | Ровно один |

# Билет 50. Диаграмма классов UML. Отношение ассоциации

**Ассоциация** (association) – это семантическая связь между классами. Их рисуют на диаграмме классов в виде обыкновенной линии. 				
![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-21%20at%2022.26.00.png?_subject_uid=76410387&w=AADmja7C1DjxasA7h9Gr5y53QOR2VWWKiGd7RnX8wfQxaQ)

Ассоциации могут быть двунаправленными, как в примере, или однонаправленными. На языке UML двунаправленные ассоциации рисуют в виде простой линии без стрелок или со стрелками с обеих ее сторон. На однонаправленной ассоциации изображают только одну стрелку, показывающую ее направление.
					
Направление ассоциации можно определить, изучая диаграммы последовательности и кооперативные диаграммы. Если все сообщения на них отправляются только одним классом и принимаются только другим классом, но не наоборот, между этими классами имеет место однонаправленная связь. Если хотя бы одно сообщение отправляется в обратную сторону, ассоциация должна быть двунаправленной.
					
Ассоциации могут быть рефлексивными. Рефлексивная ассоциация предполагает, что один экземпляр класса взаимодействует с другими экземплярами этого же класса. 

# Билет 51. Диаграмма классов UML. Квалификатор ассоциации

Если кратность ассоциации описывается отношением “один ко многим”, возникает проблема поиска. Если объект одного класса для выполнения отведенной ему роли в ассоциации должен выбрать конкретный объект другого класса, то он может сделать это на основе некоторого заданного атрибута. Этот атрибут обычно представляет собой идентификатор, например числовой. В частности, в списке зарезервированных номеров отеля содержится много заказов

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-21%20at%2022.27.25.png?_subject_uid=76410387&w=AACJhw-tsIkq3wklcfAKjLrgmpJUDRyC3tMabhMmxwq1TA)

Когда вы резервируете место в гостинице, вашему заказу присваивается номер. Если нужно узнать о наличии зарезервированного места, необходимо сообщить номер заказа.
В UML идентифицирующая информация называется квалификатором. Он обозначается небольшим прямоугольником, который прилегает к обозначению одиночного класса в отношении “один ко многим”. Хотя кратность ассоциации между классами СписокЗаказов и Заказ составляет “один ко многим”, кратность ассоциации между квалификатором номерПодтверждения и классом Заказ - “один к одному”.

![](https://dl-web.dropbox.com/get/ТСПП%20Скриншоты/Screen%20Shot%202014-12-21%20at%2022.27.31.png?_subject_uid=76410387&w=AAAFxXBcQE8pr3NDeYXEilPR-g_L11QRUFfu32IVhDSCNA)
# Билет 52.Диаграмма классов UML. Свойства ассоциации. Видимость ролей ассоциации.

Ассоциацией называется структурная связь, показывающая, что объекты одного класса некоторым образом связаны с объектами другого или того же самого класса. Допускается, чтобы оба конца ассоциации относились к одному классу. В ассоциации могут связываться два класса, и тогда она называется бинарной. Допускается создание ассоциаций, связывающих сразу n классов (они называются n-арными ассоциациями).55) Графически ассоциация изображается в виде линии, соединяющей класс сам с собой или с другими классами.
С понятием ассоциации связаны четыре важных дополнительных понятия: имя, роль, кратность и агрегация. Во-первых, ассоциации может быть присвоено имя, характеризующее природу связи. Смысл имени уточняется с помощью черного треугольника, который располагается над линией связи справа или слева от имени ассоциации. Этот треугольник указывает направление чтения имя связи. Пример именованной ассоциации показан на рис. 11.7. Треугольник показывает, что именованная ассоциация должна читаться как «Студент учится в Университете».

￼￼![image](https://dl.dropboxusercontent.com/u/8382381/images/52_1.png)

Другим способом именования ассоциации является указание роли каждого класса, участвующего в этой ассоциации. Роль класса, как и имя конца связи в ER-модели, задается именем, помещаемым под линией ассоциации ближе к данному классу. На рис. 11.8 показаны две ассоциации между классами Человек и Университет, в которых эти классы играют разные роли. Как мы видим, объекты класса Человек могут выступать в роли РАБОТНИКОВ при участии в ассоциации, в которой объекты класса Университет играют роль НАНИМАТЕЛЯ. В другой ассоциации объекты класса Человек играют роль СТУДЕНТА, а объекты класса УНИВЕРСИТЕТ – роль ОБУЧАЮЩЕГО.

![image](https://dl.dropboxusercontent.com/u/8382381/images/52_2.png)

В общем случае, для ассоциации могут задаваться и ее собственное имя, и имена ролей классов. Это связано с тем, что класс может играть одну и ту же роль в разных ассоциациях, так что в общем случае пара имен ролей классов не идентифицирует ассоциацию. С другой стороны, в простых случаях, когда между двумя классами определяется только одна ассоциация, можно вообще не связывать с ней дополнительные имена.
Кратностью (multiplicity) роли ассоциации называется характеристика, указывающая, сколько объектов класса с данной ролью может или должно участвовать в каждом экземпляре ассоциации (в UML экземпляр ассоциации называется соединением – link, но мы не будем здесь использовать этот термин, чтобы не создавать путаницу – все-таки трудно одновременно говорить про связи, ассоциации и соединения, имея в виду разные понятия). Наиболее распространенным способом задания кратности роли ассоциации является указание конкретного числа или диапазона. Например, указание «1» говорит о том, что каждый объект класса с данной ролью должен участвовать в некотором экземпляре данной ассоциации, причем в каждом экземпляре ассоциации может участвовать ровно один объект класса с данной ролью. Указание диапазона «0..1» говорит о том, что не все объекты класса с данной ролью обязаны участвовать в каком-либо экземпляре данной ассоциации, но в каждом экземпляре ассоциации может участвовать только один объект. Аналогично, указание диапазона «1..\*» говорит о том, что все объекты класса с данной ролью должны участвовать в некотором экземпляре данной ассоциации, и в каждом экземпляре ассоциации должен участвовать хотя бы один объект (верхняя граница не задана). Толкование диапазона «0..\*» является очевидным расширением случая «0..1».
В более сложных (но крайне редко встречающихся на практике) случаях определения кратности можно использовать списки диапазонов. Например, список «2, 4..6, 8..*» говорит о том, что все объекты класса с указанной ролью должны участвовать в некотором экземпляре данной ассоциации, и в каждом экземпляре ассоциации должны участвовать два, от четырех до шести или более семи объектов класса с данной ролью.
На диаграмме классов с рис. 11.9 показано, что произвольное (может быть, нулевое) число людей являются служащими произвольного числа университетов. Каждый университет обучает произвольное (может быть, нулевое) число студентов, но каждый студент может быть студентом только одного университета.

![image](https://dl.dropboxusercontent.com/u/8382381/images/52_3.png)


# Билет 53.Диаграмма классов UML. Отношения агрегации и композиции. 

Обычная ассоциация между двумя классами характеризует связь между равноправными сущностями: оба класса находятся на одном концептуальном уровне. Но иногда в диаграмме классов требуется отразить тот факт, что ассоциация между двумя классами имеет специальный вид «часть-целое». В этом случае класс «целое» имеет более высокий концептуальный уровень, чем класс «часть». Ассоциация такого рода называется агрегатной. Графически агрегатные ассоциации изображаются в виде простой ассоциации с незакрашенным ромбом на стороне класса-«целого». Простой пример агрегатной ассоциации показан на рис. 11.10.


![image](https://dl.dropboxusercontent.com/u/8382381/images/53_1.png)


Объектами класса Аудитория являются студенческие аудитории, в которых проходят занятия. В каждой аудитории должны быть установлены парты. Поэтому в некотором смысле класс Парта является «частью» класса Аудитория. Мы умышленно сделали роль класса Парта необязательной, поскольку могут существовать аудитории без парт (например, класс для занятий танцами) и некоторые парты могут находиться на складе. Обратите внимание, что, хотя аудитории, не оснащенные партами, как правило, непригодны для занятий, объекты классов Аудитория и Парта существуют независимо. Если некоторая аудитория ликвидируется, то находящиеся в ней парты не уничтожаются, а переносятся на склад.

Бывают случаи, когда связь «части» и «целого» настолько сильна, что уничтожение «целого» приводит к уничтожению всех его «частей». Агрегатные ассоциации, обладающие таким свойством, называются композитными, или просто композициями. При наличии композиции объект-часть может быть частью только одного объекта-целого (композита). При обычной агрегатной ассоциации «часть» может одновременно принадлежать нескольким «целым». Графически композиция изображается в виде простой ассоциации, дополненной закрашенным ромбом со стороны «целого». Пример композитной агрегатной ассоциации показан на рис. 11.11.

![image](https://dl.dropboxusercontent.com/u/8382381/images/53_2.png)


Любой факультет является частью одного университета, и ликвидация университета приводит к ликвидации всех существующих в нем факультетов (хотя во время существования университета отдельные факультеты могут ликвидироваться и создаваться).
Заметим, что в контексте проектирования реляционных БД агрегатные и в особенности композитные ассоциации влияют только на способ поддержки ссылочной целостности. В частности, композитная связь является явным указанием на то, что ссылочная целостность между «целым» и «частями» должна поддерживаться путем каскадного удаления частей при удалении целого. Подробнее способы поддержки ссылочной целостности в SQL-ориентированных БД рассматриваются в следующих лекциях.
При наличии простой ассоциации между двумя классами (например, ассоциации между классами Студент и Университет с рис. 11.7) предполагается возможность навигации между объектами, входящими в один экземпляр ассоциации. Если известен конкретный объект-студент, то должна обеспечиваться возможность узнать соответствующий объект-университет. Если известен конкретный объект-университет, то должна обеспечиваться возможность узнать все соответствующие объекты-студенты. Другими словами, если не оговорено иное, то навигация по ассоциации может проводиться в обоих направлениях.56) Однако бывают случаи, когда желательно ограничить направление навигации для некоторых ассоциаций. В этом случае на линии ассоциации ставится стрелка, указывающая направление навигации. Пример показан на рис. 11.12.

![image](https://dl.dropboxusercontent.com/u/8382381/images/53_3.png)


В библиотеке должно содержаться некоторое количество книг, и каждая книга должна принадлежать некоторой библиотеке. С точки зрения библиотечного хозяйства разумно иметь возможность найти книгу в библиотеке, т. е. произвести навигацию от объекта-библиотеки к связанным с ним объектам-книгам. Однако вряд ли потребуется по данному экземпляру книги узнать, в какой библиотеке она находится.57)

# Билет 54.Диаграмма классов UML. Отношения зависимости, обобщения и реализации.

В диаграмме классов могут участвовать связи трех разных категорий: зависимость (dependency), обобщение (generalization) и ассоциация (association). При проектировании реляционных БД наиболее важны вторая и третья категории связей, поэтому о связях-зависимостях будет сказано только самое основное.
Зависимостью называют связь по применению, когда изменение в спецификации одного класса может повлиять на поведение другого класса, использующего первый класс. Чаще всего зависимости применяют в диаграммах классов, чтобы отразить в сигнатуре операции одного класса тот факт, что параметром этой операции могут быть объекты другого класса. Понятно, что если интерфейс второго класса изменяется, это влияет на поведение объектов первого класса. Простой пример диаграммы классов со связью-зависимостью показан на рис. 11.4.
 ![image](https://dl.dropboxusercontent.com/u/8382381/images/54_1.png)

Зависимость показывается прерывистой линией со стрелкой, направленной к классу, от которого имеется зависимость. Очевидно, что связи-зависимости существенны для объектно-ориентированных систем.

Связью-обобщением называется связь между общей сущностью, называемой суперклассом, или родителем, и более специализированной разновидностью этой сущности, называемой подклассом, или потомком. Обобщения иногда называют связями «is a», имея в виду, что класс-потомок является частным случаем класса-предка. Класс-потомок наследует все атрибуты и операции класса-предка, но в нем могут быть определены дополнительные атрибуты и операции.
Объекты класса-потомка могут использоваться везде, где могут использоваться объекты класса-предка. Это свойство называют полиморфизмом по включению, имея в виду, что объекты потомка можно считать включаемыми во множество объектов класса-предка. Графически обобщения изображаются в виде сплошной линии с большой незакрашенной стрелкой, направленной к суперклассу. В качестве первой иллюстрации, приведенной на рис. 11.5, воспользуемся классификацией летательных аппаратов с рис. 10.12 из предыдущей лекции. На рис. 11.5 показан пример иерархии одиночного наследования: у каждого подкласса имеется только один суперкласс.
 
![image](https://dl.dropboxusercontent.com/u/8382381/images/54_2.png)

Одиночное наследование является достаточным в большинстве случаев применения связи-обобщения. Однако в UML допускается и множественное наследование, когда один подкласс определяется на основе нескольких суперклассов. В качестве одного из разумных (не слишком распространенных) примеров рассмотрим диаграмму классов на рис. 11.6 (для упрощения диаграммы имена атрибутов и операций указывать не будем).

![image](https://dl.dropboxusercontent.com/u/8382381/images/54_3.png)

На этой диаграмме классы Студент и Преподаватель порождены из одного суперкласса ЧеловекИзУниверситета. Вообще говоря, к классу Студент относятся те объекты класса ЧеловекИзУниверситета, которые соответствуют студентам, а к классу Преподаватель – объекты класса ЧеловекИзУниверситета, соответствующие преподавателям. Но, как это часто случается, многие студенты уже в студенческие годы начинают преподавать, так что могут существовать такие два объекта классов Студент и Преподаватель, которым соответствует один объект класса ЧеловекИзУниверситета. Итак, среди объектов класса Студент могут быть преподаватели, а некоторые преподаватели могут быть студентами. Тогда мы можем определить класс СтудентПреподаватель путем множественного наследования от суперклассов Студент и Преподаватель. Объект класса СтудентПреподаватель обладает всеми свойствами и операциями классов Студент и Преподаватель и может быть использован везде, где могут применяться объекты этих классов. Так что полиморфизм по включению продолжает работать. Следует отметить, что множественное наследование, помимо того что не слишком часто требуется на практике, порождает ряд проблем, из которых одной из наиболее известных является проблема именования атрибутов и операций в подклассе, полученном путем множественного наследования. Например, предположим, что при образовании подклассов Студент и Преподаватель в них обоих был определен атрибут с именем номерКомнаты. Очень вероятно, что для объектов класса Студент значениями этого атрибута будут номера комнат в студенческом общежитии, а для объектов класса Преподаватель – номера служебных кабинетов. Как быть с объектами класса СтудентПреподаватель, для которых существенны оба одноименных атрибута (у студента-преподавателя могут иметься и комната в общежитии, и служебный кабинет)? На практике применяется одно из следующих решений:


* запретить образование подкласса СтудентПреподаватель, пока в одном из суперклассов не будет произведено переименование атрибута номерКомнаты;
* наследовать это свойство только от одного из суперклассов, так что, например, значением атрибута номерКомнаты у объектов класса СтудентПреподаватель всегда будут номера служебных кабинетов;
* унаследовать в подклассе оба свойства, но автоматически переименовать оба атрибута, чтобы прояснить их смысл; назвать их, например, номерКомнатыСтудента и номерКомнатыПреподавателя.

нужно очень осторожно использовать наследование классов вообще и стараться избегать множественного наследования.54)

Реализация (realization) - это семантическое отношение между классификаторами, при котором один классификатор определяет обязательство, а другой гарантирует его выполнение.
Отношение реализации встречаются в двух случаях:


* во-первых - между интерфейсами и реализующими их классами или компонентами,
* 5	а во-вторых - между прецедентами и реализующими их кооперациями (конкретными связми между конкретными классами - так например "сотрудничать" могут как две компании так и компания и конкретный человек).
Отношение реализации изображается в виде пунктирной линии с незакрашенной стрелкой (треугольником на конце), как нечто среднее между отношениями обобщения и зависимости -
стрелка направлена на "шаблон" - то есть на ту сущность, которая задаёт правила собственной реализации для сущности (реализуемая), которая эти правила выполняет (реализующая).

![image](https://dl.dropboxusercontent.com/u/8382381/images/54_4.png)
 
Пример (два нижних класса реализуют интерфейс) 

![image](https://dl.dropboxusercontent.com/u/8382381/images/54_5.png)


# Билет 55.Диаграмма классов UML. Деревья наследования. 
Связью-обобщением называется связь между общей сущностью, называемой суперклассом, или родителем, и более специализированной разновидностью этой сущности, называемой подклассом, или потомком. Обобщения иногда называют связями «is a», имея в виду, что класс-потомок является частным случаем класса-предка. Класс-потомок наследует все атрибуты и операции класса-предка, но в нем могут быть определены дополнительные атрибуты и операции.
Объекты класса-потомка могут использоваться везде, где могут использоваться объекты класса-предка. Это свойство называют полиморфизмом по включению, имея в виду, что объекты потомка можно считать включаемыми во множество объектов класса-предка. Графически обобщения изображаются в виде сплошной линии с большой незакрашенной стрелкой, направленной к суперклассу. В качестве первой иллюстрации, приведенной на рис. 11.5, воспользуемся классификацией летательных аппаратов с рис. 10.12 из предыдущей лекции. На рис. 11.5 показан пример иерархии одиночного наследования: у каждого подкласса имеется только один суперкласс.

![image](https://dl.dropboxusercontent.com/u/8382381/images/55_1.png)

Одиночное наследование является достаточным в большинстве случаев применения связи-обобщения. Однако в UML допускается и множественное наследование, когда один подкласс определяется на основе нескольких суперклассов. В качестве одного из разумных (не слишком распространенных) примеров рассмотрим диаграмму классов на рис. 11.6 (для упрощения диаграммы имена атрибутов и операций указывать не будем). 

![image](https://dl.dropboxusercontent.com/u/8382381/images/55_2.png)

На этой диаграмме классы Студент и Преподаватель порождены из одного суперкласса ЧеловекИзУниверситета. Вообще говоря, к классу Студент относятся те объекты класса ЧеловекИзУниверситета, которые соответствуют студентам, а к классу Преподаватель – объекты класса ЧеловекИзУниверситета, соответствующие преподавателям. Но, как это часто случается, многие студенты уже в студенческие годы начинают преподавать, так что могут существовать такие два объекта классов Студент и Преподаватель, которым соответствует один объект класса ЧеловекИзУниверситета. Итак, среди объектов класса Студент могут быть преподаватели, а некоторые преподаватели могут быть студентами. Тогда мы можем определить класс СтудентПреподаватель путем множественного наследования от суперклассов Студент и Преподаватель. Объект класса СтудентПреподаватель обладает всеми свойствами и операциями классов Студент и Преподаватель и может быть использован везде, где могут применяться объекты этих классов. Так что полиморфизм по включению продолжает работать. Следует отметить, что множественное наследование, помимо того что не слишком часто требуется на практике, порождает ряд проблем, из которых одной из наиболее известных является проблема именования атрибутов и операций в подклассе, полученном путем множественного наследования. Например, предположим, что при образовании подклассов Студент и Преподаватель в них обоих был определен атрибут с именем номерКомнаты. Очень вероятно, что для объектов класса Студент значениями этого атрибута будут номера комнат в студенческом общежитии, а для объектов класса Преподаватель – номера служебных кабинетов. Как быть с объектами класса СтудентПреподаватель, для которых существенны оба одноименных атрибута (у студента-преподавателя могут иметься и комната в общежитии, и служебный кабинет)? На практике применяется одно из следующих решений:


* запретить образование подкласса СтудентПреподаватель, пока в одном из суперклассов не будет произведено переименование атрибута номерКомнаты;
* наследовать это свойство только от одного из суперклассов, так что, например, значением атрибута номерКомнаты у объектов класса СтудентПреподаватель всегда будут номера служебных кабинетов;
* унаследовать в подклассе оба свойства, но автоматически переименовать оба атрибута, чтобы прояснить их смысл; назвать их, на
пример, номерКомнатыСтудента и номерКомнатыПреподавателя.

Ни одно из решений не является полностью удовлетворительным. Первое решение требует возврата к ранее определенному классу, имена атрибутов и операций которого, возможно, уже используются в приложениях. Второе решение нарушает логику наследования, не давая возможности на уровне подкласса использовать все свойства суперклассов. Наконец, третье решение заставляет использовать длинные имена атрибутов и операций, которые могут стать недопустимо длинными, если процесс множественного наследования будет продолжаться от полученного подкласса.53)

Нужно очень осторожно использовать наследование классов вообще и стараться избегать множественного наследования

# Билет 56.Диаграммы деятельности. 
Создание Информационной Системы – сложный процесс, который можно представить как поэтапный спуск от общей концепции будущей ИС, через понимание ее логической структуры к наиболее детальным моделям, описывающим физическую реализацию. Диаграмма деятельности принадлежит к логической модели.  
В качестве графического представления для выделения основных функций Системы мы применяем диаграмму вариантов использования (use case). 
Диаграмма вариантов использования дает нам представление ЧТО должна делать Система. На вопрос КАК мы можем ответить, используя диаграмму активности. 

![image](https://dl.dropboxusercontent.com/u/8382381/images/56_1.png)


Чтобы указать, где именно находится процесс, используется абстрактная точка «маркер» (или «токен»). Визуально на диаграмме маркер не показывается, данное понятие вводится только для удобства описания динамического процесса.   

Для создания диаграммы деятельности используются следующие узлы:

Узел решения предназначен для определения правила ветвления и различных вариантов дальнейшего развития сценария.  

![image](https://dl.dropboxusercontent.com/u/8382381/images/56_2.png)

В точку ветвления входит ровно один переход, а выходит - два или более. Для каждого исходящего перехода задается булевское выражение. Желательно чтобы условия покрывали все возможные варианты, иначе поток остановится.
Для пометки исходящего перехода, который должен быть выбран в случае, если условия, заданные для всех остальных переходов не выполнены, разрешается использовать ключевое слово else.

Далее следует обратить внимание на такой элемент, как узел объединение. Узел объединения имеет два и более входящих узла и один исходящий. 

Узлы  решения объединения аналогичны логическому выражению «строгое или», т.е. для узла объединения - только при выполнении того или иного действия осуществляется переход к следующему узлу управления. Соответственно для узла решения – только при выполнении того или иного условия становится доступна возможность перехода к одному из следующих действий. 
Для отображения условий соответствующих логическому оператору «и» на диаграмме используются синхронизационная черта. 

![image](https://dl.dropboxusercontent.com/u/8382381/images/56_3.png)


Точка разделения обеспечивает разделение одного потока на несколько параллельных потоков:
* входит ровно один поток;
* выходит два и более потока, каждый из которых далее выполняется параллельно с другими.
	
Точка слияния обеспечивает синхронизацию нескольких параллельных потоков.
* входят два или более потока, причем эти потоки выполняются параллельно;
* выходит ровно один поток, причем в точке слияния входящие параллельные потоки синхронизируются, то есть каждый из них ждет, пока все остальные достигнут этой точки, после чего выполнение продолжается в рамках одного потока.

Также диаграмма действия может описывать поведение, на которое оказывают влияние внешние события, происходящие за пределами данной Системы.
На диаграмме это может быть показано при помощи изображения передачи сигнала. 


![image](https://dl.dropboxusercontent.com/u/8382381/images/56_4.png)

Передача сигнала (send signal action) - действие, которое на основе своих входов создает экземпляр сигнала и передает его внешней Системе. 
Прием события (receive event action) - действие, которое ожидает некоторого события, принимает и обрабатывает полученное сообщение. 

# Билет 57.Актеры и элементы Use Case.

![image](https://dl.dropboxusercontent.com/u/8382381/images/57_1.png)

Диаграммы вариантов использования описывают взаимоотношения и зависимости между группами вариантов использования и действующих лиц, участвующими в процессе.

Важно понимать, что диаграммы вариантов использования не предназначены для отображения проекта и не могут описывать внутреннее устройство системы. Диаграммы вариантов использования предназначены для упрощения взаимодействия с будущими пользователями системы, с клиентами, и особенно пригодятся для определения необходимых характеристик системы. Другими словами, диаграммы вариантов использования говорят о том, что система должна делать, не указывая сами применяемые методы.

Вариант использования (use case)
Вариант использования описывает, с точки зрения действующего лица, группу действий в системе, которые приводят к конкретному результату.

Для отражения модели прецедентов на диаграмме используются[1]:

* рамки системы (англ. system boundary) — прямоугольник с названием в верхней части и эллипсами (прецедентами) внутри. Часто может быть опущен без потери полезной информации,
* актёр («эктор») — стилизованный человечек, обозначающий набор ролей пользователя (понимается в широком смысле: человек, внешняя сущность, класс, другая система), взаимодействующего с некоторой сущностью (системой, подсистемой, классом). Актёры не могут быть связаны друг с другом (за исключением отношений обобщения/наследования),
* прецедент — эллипс с надписью, обозначающий выполняемые системой действия (могут включать возможные варианты), приводящие к наблюдаемым актёрами результатам. Надпись может быть именем или описанием (с точки зрения актёров) того, «что» делает система (а не «как»). Имя прецедента связано с непрерываемым (атомарным) сценарием — конкретной последовательностью действий, иллюстрирующей поведение[2]. В ходе сценария актёры обмениваются с системой сообщениями. Сценарий может быть приведён на диаграмме прецедентов в виде UML-комментария. С одним прецедентом может быть связано несколько различных сценариев[1].


## Отношения между прецедентами
Часть дублирующейся информации в модели прецедентов можно устранить указанием связей между прецедентами[1]:

* обобщение прецедента — стрелка с незакрашенным треугольником (треугольник ставится у более общего прецедента),
* включение прецедента — пунктирная стрелка со стереотипом «include»,
* расширение прецедента — пунктирная стрелка со стереотипом «extend» (стрелка входит в расширяемый прецедент, в дополнительном разделе которого может быть указана точка расширения и, возможно в виде комментария, условие расширения)

Действующее лицо (actor)
Действующее лицо является внешним источником (не элементом системы), который взаимодействует с системой через вариант использования. Действующие лица могут быть как реальными людьми (например, пользователями системы), так и другими компьютерными системами или внешними событиями. 

Действующие лица представляют не физических людей или системы, а их роли. Эти означает, что когда человек взаимодействует с системой различными способами (предполагая различные роли), он отображается несколькими действующими лицами. Например, человек, работающий в службе поддержки и принимающий от клиентов заказы, будет отображаться в системе как «участник отдела поддержки» и «участник отдела продаж». 

Действующие лица могут иметь два типа связей с вариантами использования:
* Простая ассоциация — отражается линией между актером и вариантом использования (без стрелки). Отражает связь актера и варианта использования.
* Направленная ассоциация — то же что и простая ассоциация, но показывает, что вариант использования инициализируется актером. Обозначается стрелкой.


Элемент Use Case (Прецедент) – описание последовательности действий (или нескольких последовательностей), выпол- няемых системой в интересах отдельного актёра и производящих видимый для актёра результат. В модели элемент Use Case при- меняется для структурирования предметов поведения. Элемент Use Case реализуется кооперацией. Как показано на рис. 3.5, эле- мент Use Case изображается как эллипс, в который вписывается его имя. 

# Билет 58.Отношения в диаграммах Use Case.

Диаграмма деятельности принадлежит к логической модели.  
В качестве графического представления для выделения основных функций Системы мы применяем диаграмму вариантов использования (use case). 
Диаграмма вариантов использования дает нам представление ЧТО должна делать Система. На вопрос КАК мы можем ответить, используя диаграмму активности. 

Важно понимать, что диаграммы вариантов использования не предназначены для отображения проекта и не могут описывать внутреннее устройство системы. Диаграммы вариантов использования предназначены для упрощения взаимодействия с будущими пользователями системы, с клиентами, и особенно пригодятся для определения необходимых характеристик системы. Другими словами, диаграммы вариантов использования говорят о том, что система должна делать, не указывая сами применяемые методы.

Действующее лицо является внешним источником (не элементом системы), который взаимодействует с системой через вариант использования. Действующие лица могут быть как реальными людьми (например, пользователями системы), так и другими компьютерными системами или внешними событиями. 

Элемент Use Case (Прецедент) – описание последовательности действий (или нескольких последовательностей), выпол- няемых системой в интересах отдельного актёра и производящих видимый для актёра результат.

Между актерами и вариантами использования могут быть различные виды взаимодействия. Основные виды взаимодействия следующие:

* Простая ассоциация - отражается линией между актером и вариантом использования (без стрелки). Отражает связь актера и варианта использования. На рисунке между актером администратор и вариантом использования просматривать заказ.
* Направленная ассоциация - то же что и простая ассоциация, но показывает, что вариант использования инициализируется актером. Обозначается стрелкой.
* Наследование - показывает, что потомок наследует атрибуты и поведение своего прямого предка. Может применяться как для актеров, так для вариантов использования. 
* Расширение (extend) - показывает, что вариант использования расширяет базовую последовательность действий и вставляет собственную последовательность. При этом в отличие от типа отношений "включение" расширенная последовательность может осуществляться в зависимости от определенных условий. 
* Включение - показывает, что вариант использования включается в базовую последовательность и выполняется всегда (на рисунке не показан). 

В языке UML на диаграммах вариантов использования поддерживается несколько типов связей между элементами диаграммы. Это связи коммуникации (communication), включения (include), расширения (extend) и обобщения (generalization). 
Связь коммуникации – это связь между вариантом использования и действующим лицом. На языке UML связи коммуникации показывают с помощью однонаправленной ассоциации (сплошной линии со стрелкой). Направление стрелки позволяет понять, кто инициирует коммуникацию. 
Связь включения применяется в тех ситуациях, когда имеется какой-либо фрагмент поведения системы, который повторяется более чем водном варианте использования. С помощью таких связей обычно моделируют многократно используемую функциональность. В примере АТМ варианты использования «Снять деньги» и «Положить деньги насчет» должны опознать (аутентифицировать) клиента и его идентификационный номер перед тем, как допустить осуществление самой транзакции. Вместо того чтобы подробно описывать процесс 
аутентификации для каждого из них, эту функциональность в свой собственный под названием «Аутентифицировать клиента». 
можно поместить вариант использования 
Связь расширения применяется при описании изменений в нормальном поведении системы. Она позволяет варианту использования только при необходимости использовать функциональные возможности другого. 
На языке UML связи включения и расширения показывают в виде зависимостей с соответствующими стереотипами, как показано на рис. 1.2. 

![image](https://dl.dropboxusercontent.com/u/8382381/images/58_1.png)


# Билет 59.Спецификация элементов Use Case

Спецификация элемента Use Case — основной источник информации для выполнения анализа и проектирования системы. Очень важно, чтобы содержание спецификации было представлено в полной и конструктивной форме. В общем случае спецификация включает главный поток, подпотоки и альтернативные потоки поведения. В качестве шаблона спецификации представим описание элемента Use Case «Покупать авиабилет» для модели информационной системы авиакассы.
Предусловие: перед началом этого элемента Use Case должен быть выполнен элемент Use Case «Заполнить базу данных авиарейсов».

## Главный поток
 
Этот элемент Use Case начинается, когда покупатель регистрируется в системе и вводит свой пароль. Система проверяет, правилен ли пароль (Е-1), и предлагает покупателю выбрать одно из действий: СОЗДАТЬ, УДАЛИТЬ, ПРОВЕРИТЬ, ВЫПОЛНИТЬ, ВЫХОД.
1. Если выбрано действие СОЗДАТЬ, выполняется подпоток S-1: создать заказ авиабилета.
2. Если выбрано действие УДАЛИТЬ, выполняется подпоток S-2: удалить заказ авиабилета.
3. Если выбрано действие ПРОВЕРИТЬ, выполняется подпоток S-3: проверить заказ авиабилета.
4. Если выбрано действие ВЫПОЛНИТЬ, выполняется подпоток S-4: реализовать заказ авиабилета.
5. Если выбрано действие ВЫХОД, элемент Use Case заканчивается.

S-1: создать заказ авиабилета. Система отображает диалоговое окно, содержащее поля для пункта назначения и даты полета. Покупатель вводит пункт назначения и дату полета (Е-2). Система отображает параметры авиарейсов (Е-3). Покупатель выбирает авиарейс. Система связывает покупателя с выбранным авиарейсом (Е-4). Возврат к началу элемента Use Case.
S-2: удалить заказ авиабилета. Система отображает параметры заказа. Покупатель подтверждает решение о ликвидации заказа (Е-5). Система удаляет связь с покупателем (Е-6). Возврат к началу элемента Use Case.
S-3: проверить заказ авиабилета. Система выводит (Е-7) и отображает параметры заказа авиабилета: номер рейса, пункт назначения, дата, время, место, цену. Когда покупатель указывает, что он закончил проверку, выполняется возврат к началу элемента Use Case.
S-4: реализовать заказ авиабилета. Система запрашивает параметры кредитной карты покупателя. Покупатель вводит параметры своей кредитной карты (Е-8). Возврат к началу элемента Use Case.

## Альтернативные потоки
 
Е-1: введен неправильный ID-номер покупателя. Покупатель может повторить ввод ID-номера или прекратить элемент Use Case.
Е-2: введены неправильные пункт назначения/дата полета. Покупатель может повторить ввод пункта назначения/даты полета или прекратить элемент Use Case.
Е-3: нет подходящих авиарейсов. Покупатель информируется, что в данное время такой полет невозможен. Возврат к началу элемента Use Case.
Е-4: не может быть создана связь между покупателем и авиарейсом. Информация сохраняется, система создаст эту связь позже. Элемент Use Case продолжается.
Е-5: введен неправильный номер заказа. Покупатель может повторить ввод правильного номера заказа или прекратить элемент Use Case.
Е-6: не может быть удалена связь между покупателем и авиарейсом. Информация сохраняется, система будет удалять эту связь позже. Элемент Use Case продолжается.
Е-7: система не может вывести информацию заказа. Возврат к началу элемента Use Case.
Е-8: некорректные параметры кредитной карты. Покупатель может повторить ввод параметров карты или прекратить элемент Use Case.
Таким образом, в данной спецификации зафиксировано, что внутри элемента Use Case находится один основной поток и двенадцать вспомогательных потоков действий. В дальнейшем разработчик может принять решение о выделении из этого элемента Use Case самостоятельных элементов Use Case. Очевидно, что если самостоятельный элемент Use Case содержит подпоток, то его следует подключать к базовому элементу Use Case отношением include. В свою очередь, самостоятельный элемент Use Case с альтернативным потоком подключается к базовому элементу Use Case отношением extend.
	

# Билет 60. Диаграммы сотрудничества (Бондаренко)

**Диаграмма сотрудничества** — этот тип диаграмм позволяет описать взаимодействия объектов, абстрагируясь от последовательности передачи сообщений. На этом типе диаграмм в компактном виде отражаются все принимаемые и передаваемые сообщения конкретного объекта и типы этих сообщений.

**Кооперация (Collaboration)** - это сообщество классов, интерфейсов и других элементов, которые работают совместно для обеспечения кооперативного поведения, более значимого, чем сумма его составляющих

![](http://konspekta.net/studopediaorg/baza1/198653165094.files/image116.jpg)

Такая диаграмма компактно отражает принимаемые и передаваемые сообщения объекта и их типы и может описать взаимодействие объектов независимо от последовательности передачи сообщений.

По причине того, что диаграммы Sequence и Collaboration являются разными взглядами на одни и те же процессы, Rational Rose позволяет создавать из Sequence диаграммы диаграмму Collaboration и наоборот, а также производит автоматическую синхронизацию этих диаграмм.

## Структурные элементы диаграммы коопераций:

1. Классы
2. Объекты
3. Связи
4. Сообщения
5. Роли

## Уровни кооперации

Выделяют следующие уровни кооперации:

1. **уровень спецификации** - показывает роли классификаторов и роли ассоциаций в рассматриваемом взаимодействии.
2. **уровень примеров** - указывает экземпляры и связи, образующие отдельные роли в кооперации.

## Уровнень спецификации

Его элементы:

1. Классы
2. Ассоциации

# Билет  64. Гибкие методы разработки программного обеспечения (Метод Scrum ).

**Scrum** (от англ. scrum «толкучка») — методология управления проектами, активно применяющаяся при разработке информационных систем для гибкой разработки программного обеспечения. Scrum чётко делает акцент на качественном контроле процесса разработки. Кроме управления проектами по разработке ПО Scrum может также использоваться в работе команд поддержки программного обеспечения (software support teams), или как подход управления разработкой и сопровождением программ

Противовес стандартной модели разработки — «гибкая» модель (Scrum).
В Scrum весь процесс разработки строится иначе:

1.	Вы также анализируете потребности бизнеса, но вместо технического задания просто готовите список всех функций (в этом вам помогает руководитель проекта).

2.	Функциям присваивается приоритет (например, для интернет-магазина каталог товаров важнее, чем личный кабинет пользователя — следовательно, приоритет первого будет ощутимо выше).

Пример типичного списка компонентов интернет-магазина, с приоритетами:

1.	Разработка идет отдельными этапами по принципу: выбрали на этап самые приоритетные функции (на рисунке отмечены красным) → подготовили дизайн → сверстали → запрограммировали → запустили проект с минимальным функционалом → снова выбрали приоритетные функции… И так до последнего этапа.

2.	В результате каждого этапа вы получаете полностью готовый, работоспособный проект, в котором реализованы самые важные с точки зрения вашего бизнеса функции. Который уже можно запускать.

3.	Пока идет, например, первый этап разработки, вы можете пересмотреть свое видение проекта и что-то поменять в последующих. И эти изменения не будут дорогостоящими, как в «водопаде».

4.	Каждый последующий этап будет наращивать функционал проекта, пока все функции не будут реализованы.

Итак, если говорить об особенностях работы по Scrum’у, то нужно отметить:

**Прозрачность.** В Scrum’е после каждого этапа разработки вам будут демонстрировать то, что получилось, а еще регулярно снабжать наглядными отчетами о том, как идут дела на проекте. Кстати, «хроника» работы над проектом, которая содержится в таких отчетах — очень полезная вещь при общении с боссом.

**Быстрые, дешевые изменения**. Разработка ведется «кусочками», и это позволяет вам быстро внедрять новое в проект. Например, после окончания первого этапа и запуска проекта вы решили, что социальная сеть вам не нужна. Так как она имела меньший приоритет, к ней еще не приступали, а значит, вы просто связываетесь с руководителем проекта и вычеркиваете ее из общего списка функций.

**Быстрый запуск**. Проект с базовыми функциями запускается уже после первых этапов разработки, после чего он с каждым этапом «обрастает» новыми функциями. А вы этим временем можете заняться, например, продвижением интернет-проекта в поисковой выдаче.

**Гибкий бюджет**. В зависимости от того, как вы будете влиять на проект в ходе разработки — будет меняться и бюджет (причем, он может как уменьшиться, так и вырасти). В ряде случаев гибкость бюджета нежелательна, так как это мешает спланировать затраты (мы в таких случаях используем собственный метод — Scrum по фиксированной цене).  А для стратапов и других продолжительных проектов, где сложно спланировать сразу весь бюджет,  Scrum подходит безупречно.

Если у вас намечается длительный, сложный проект, которым вы живете и собираетесь жить ближайшие несколько месяцев — тогда только гибкая разработка и Scrum в помощь.
